//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//

using HalconDotNet;
using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Threading.Tasks;

namespace FunctionLib.Location
{
    public partial class GuidePositioning_HDevelopExport:IDisposable
    {
#if !(NO_EXPORT_MAIN || NO_EXPORT_APP_MAIN)
        public GuidePositioning_HDevelopExport()
        {
            // Default settings used in HDevelop 
            //HOperatorSet.SetSystem("width", 512);
            //HOperatorSet.SetSystem("height", 512);
         
            //if (HalconAPI.isWindows)
            //    HOperatorSet.SetSystem("use_window_thread", "true");

        }
#endif

        // Chapter: Graphics / Text
        // Short Description: This procedure writes a text message. 
    static    public void disp_message2(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
         HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {


            // Local control variables 

            HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
            HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
            HTuple hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
            HTuple hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1 = new HTuple();
            HTuple hv_C1 = new HTuple(), hv_FactorRow = new HTuple(), hv_FactorColumn = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Index = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_W = new HTuple(), hv_H = new HTuple();
            HTuple hv_FrameHeight = new HTuple(), hv_FrameWidth = new HTuple();
            HTuple hv_R2 = new HTuple(), hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_CurrentColor = new HTuple();

            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
            HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

            // Initialize local and output iconic variables 

            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Column: The column coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically
            //   for each new textline.
            //Box: If set to 'true', the text is written within a white box.
            //
            //prepare window
            HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
                out hv_Column2Part);
            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
                out hv_WidthWin, out hv_HeightWin);
            HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
            //
            //default settings
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
            {
                hv_Color_COPY_INP_TMP = "";
            }
            //
            hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
            //
            //Estimate extentions of text depending on font size.
            HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
            {
                hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                hv_C1 = hv_Column_COPY_INP_TMP.Clone();
            }
            else
            {
                //transform image to window coordinates
                hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
            }
            //
            //display text box depending on text size
            if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
            {
                //calculate box extents
                hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                hv_Width = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                    hv_Width = hv_Width.TupleConcat(hv_W);
                }
                hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    ));
                hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                hv_R2 = hv_R1 + hv_FrameHeight;
                hv_C2 = hv_C1 + hv_FrameWidth;
                //display rectangles
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                HOperatorSet.SetColor(hv_WindowHandle, "light gray");
                HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 3, hv_C1 + 3, hv_R2 + 3, hv_C2 + 3);
                HOperatorSet.SetColor(hv_WindowHandle, "white");
                HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
            }
            else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Box";
                throw new HalconException(hv_Exception);
            }
            //Write text.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                    )));
                if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                    "auto")))) != 0)
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
                }
                else
                {
                    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                }
                hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
                HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index));
            }
            //reset changed window settings
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                hv_Column2Part);

            return;
        }

        static public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
            HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
            HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
            HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
            HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
            HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
            HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
            HTuple hv_FactorColumn = new HTuple(), hv_UseShadow = null;
            HTuple hv_ShadowColor = null, hv_Exception = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
            HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
            HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_CurrentColor = new HTuple();
            HTuple hv_Box_COPY_INP_TMP = hv_Box.Clone();
            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
            HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

            // Initialize local and output iconic variables 
            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Column: The column coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically
            //   for each new textline.
            //Box: If Box[0] is set to 'true', the text is written within an orange box.
            //     If set to' false', no box is displayed.
            //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
            //       the text is written in a box of that color.
            //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
            //       'true' -> display a shadow in a default color
            //       'false' -> display no shadow (same as if no second value is given)
            //       otherwise -> use given string as color string for the shadow color
            //
            //Prepare window
            HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
                out hv_Column2Part);
            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
                out hv_WidthWin, out hv_HeightWin);
            HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
            //
            //default settings
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
            {
                hv_Color_COPY_INP_TMP = "";
            }
            //
            hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
            //
            //Estimate extentions of text depending on font size.
            HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
            {
                hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                hv_C1 = hv_Column_COPY_INP_TMP.Clone();
            }
            else
            {
                //Transform image to window coordinates
                hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
            }
            //
            //Display text box depending on text size
            hv_UseShadow = 1;
            hv_ShadowColor = "gray";
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
            {
                if (hv_Box_COPY_INP_TMP == null)
                    hv_Box_COPY_INP_TMP = new HTuple();
                hv_Box_COPY_INP_TMP[0] = "#fce9d4";
                hv_ShadowColor = "#f28d26";
            }
            if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
                1))) != 0)
            {
                if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
                {
                    //Use default ShadowColor set above
                }
                else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
                    "false"))) != 0)
                {
                    hv_UseShadow = 0;
                }
                else
                {
                    hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
                    //Valid color?
                    try
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                            1));
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
                        throw new HalconException(hv_Exception);
                    }
                }
            }
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
            {
                //Valid color?
                try
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
                    throw new HalconException(hv_Exception);
                }
                //Calculate box extents
                hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                hv_Width = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                    hv_Width = hv_Width.TupleConcat(hv_W);
                }
                hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    ));
                hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                hv_R2 = hv_R1 + hv_FrameHeight;
                hv_C2 = hv_C1 + hv_FrameWidth;
                //Display rectangles
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                //Set shadow color
                HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
                if ((int)(hv_UseShadow) != 0)
                {
                    HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 1, hv_C1 + 1, hv_R2 + 1, hv_C2 + 1);
                }
                //Set box color
                HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
            }
            //Write text.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                    )));
                if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                    "auto")))) != 0)
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
                }
                else
                {
                    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                }
                hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
                HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index));
            }
            //Reset changed window settings
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                hv_Column2Part);

            return;
        }


        static  public void AddRegion(HObject ho_Image, ref HObject ho_RegionUnion, HTuple hv_Winhandle,
        HTuple hv_Linewidth,bool IsCircle=true,HObject originalContour=null)
        {

            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Circle = null;
            HObject ho_Rect = null;
            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
           // HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            // dev_set_preferences(...); only in hdevelop

            HOperatorSet.SetColor(hv_Winhandle, "orange");
           
            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;
            //ho_RegionUnion.Dispose();
            //HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            while ((int)(new HTuple(hv_hv_Button.TupleNotEqual(4))) != 0)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if ((int)(new HTuple(hv_hv_Button.TupleEqual(1))) != 0)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;
                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);               
                            HOperatorSet.Union2(ho_RegionUnion, ho_Circle, out ExpTmpOutVar_0);
                        }
                       else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                 hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);            
                            HOperatorSet.Union2(ho_RegionUnion, ho_Rect, out ExpTmpOutVar_0);
                        }

                        ho_RegionUnion.Dispose();
                        ho_RegionUnion = ExpTmpOutVar_0;

                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_Image, hv_Winhandle);
                        if (ObjectValided(originalContour))
                        {
                            HOperatorSet.SetColor(hv_Winhandle, "green");
                            HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        }
                        HOperatorSet.SetColor(hv_Winhandle, "orange");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_RegionUnion, hv_Winhandle);

                        //if (ObjectValided(originalContour))
                        //{
                        //    HOperatorSet.SetColor(hv_Winhandle, "green");
                        //    HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        //}

                        HOperatorSet.SetColor(hv_Winhandle, "orange"); 
                    }
                }
                HOperatorSet.WaitSeconds(0.001);
            }
           // HOperatorSet.WaitSeconds(1);
            // dev_set_preferences(...); only in hdevelop
            
           // HOperatorSet.SetDraw(hv_Winhandle, "margin");
          
            ho_Circle.Dispose();

            return;
        }

        public static bool isContinue_drawing { get; set; } = false;
        static public void AddRegion2(HObject ho_Image, ref HObject ho_RegionUnion, HTuple hv_Winhandle,
      HTuple hv_Linewidth, bool IsCircle = true, HObject originalContour = null)
        {

            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Circle = null;
            HObject ho_Rect = null;
            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            // HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            // dev_set_preferences(...); only in hdevelop

            HOperatorSet.SetColor(hv_Winhandle, "orange");

            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;
            //ho_RegionUnion.Dispose();
            //HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            while (isContinue_drawing)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if (isContinue_drawing)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;
                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);
                            HOperatorSet.Union2(ho_RegionUnion, ho_Circle, out ExpTmpOutVar_0);
                        }
                        else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                 hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);
                            HOperatorSet.Union2(ho_RegionUnion, ho_Rect, out ExpTmpOutVar_0);
                        }

                        ho_RegionUnion.Dispose();
                        ho_RegionUnion = ExpTmpOutVar_0;

                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_Image, hv_Winhandle);
                        if (ObjectValided(originalContour))
                        {
                            HOperatorSet.SetColor(hv_Winhandle, "green");
                            HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        }
                        HOperatorSet.SetColor(hv_Winhandle, "orange");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_RegionUnion, hv_Winhandle);

                        //if (ObjectValided(originalContour))
                        //{
                        //    HOperatorSet.SetColor(hv_Winhandle, "green");
                        //    HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        //}

                        HOperatorSet.SetColor(hv_Winhandle, "orange");
                    }
                }
                HOperatorSet.WaitSeconds(0.01);
              System.Windows.Forms.Application.DoEvents();
            }
            // HOperatorSet.WaitSeconds(1);
            // dev_set_preferences(...); only in hdevelop

            // HOperatorSet.SetDraw(hv_Winhandle, "margin");
         
            ho_Circle.Dispose();

            return;
        }

        static public void AddRegion3(HObject ho_Image, ref HObject ho_RegionUnion, HTuple hv_Winhandle,
   HTuple hv_Linewidth, bool IsCircle = true)
        {

            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Circle = null;
            HObject ho_Rect = null;
            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            // HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            // dev_set_preferences(...); only in hdevelop

            HOperatorSet.SetColor(hv_Winhandle, "orange");

            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;
            //ho_RegionUnion.Dispose();
            //HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            while (isContinue_drawing)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if (isContinue_drawing)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;
                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);
                            HOperatorSet.Union2(ho_RegionUnion, ho_Circle, out ExpTmpOutVar_0);
                        }
                        else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                 hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);
                            HOperatorSet.Union2(ho_RegionUnion, ho_Rect, out ExpTmpOutVar_0);
                        }

                        ho_RegionUnion.Dispose();
                        ho_RegionUnion = ExpTmpOutVar_0;

                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_Image, hv_Winhandle);

                        HOperatorSet.SetColor(hv_Winhandle, "green");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_RegionUnion, hv_Winhandle);

                        //if (ObjectValided(originalContour))
                        //{
                        //    HOperatorSet.SetColor(hv_Winhandle, "green");
                        //    HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        //}

                        HOperatorSet.SetColor(hv_Winhandle, "green");
                    }
                }
                HOperatorSet.WaitSeconds(0.01);
                System.Windows.Forms.Application.DoEvents();
            }
            // HOperatorSet.WaitSeconds(1);
            // dev_set_preferences(...); only in hdevelop

            // HOperatorSet.SetDraw(hv_Winhandle, "margin");

            ho_Circle.Dispose();

            return;
        }

        static public void Subregion(HObject ho_InputImage, HObject ho_InputRegion, ref HObject ho_OutputRegion,
      HTuple hv_Winhandle, HTuple hv_Linewidth, bool IsCircle = true, HObject originalContour = null)
        {



            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_Circle = null, ho_Rect = null ;

            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
          //  HOperatorSet.GenEmptyObj(out ho_OutputRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
          //  ho_OutputRegion.Dispose();
          // HOperatorSet.GenEmptyRegion(out ho_OutputRegion);
            if ((int)(new HTuple(ho_InputRegion.TestEqualObj(ho_EmptyObject))) != 0)
            {
                ho_EmptyObject.Dispose();
                ho_Circle.Dispose();

                return;
            }
            ho_OutputRegion.Dispose();
            HOperatorSet.CopyObj(ho_InputRegion, out ho_OutputRegion, 1, 1);
            // dev_set_preferences(...); only in hdevelop
            HOperatorSet.SetColor(hv_Winhandle, "orange");
            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;

            while ((int)(new HTuple(hv_hv_Button.TupleNotEqual(4))) != 0)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if ((int)(new HTuple(hv_hv_Button.TupleEqual(1))) != 0)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;


                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);

                            HOperatorSet.Difference(ho_OutputRegion, ho_Circle, out ExpTmpOutVar_0);
                        }
                        else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                   hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);         
                            HOperatorSet.Difference(ho_OutputRegion, ho_Rect, out ExpTmpOutVar_0);
                        }
                        ho_OutputRegion.Dispose();
                        ho_OutputRegion = ExpTmpOutVar_0;
                        
                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_InputImage, hv_Winhandle);
                        if (ObjectValided(originalContour))
                        {
                            HOperatorSet.SetColor(hv_Winhandle, "green");
                            HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        }
                        HOperatorSet.SetColor(hv_Winhandle, "orange");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_OutputRegion, hv_Winhandle);
                       
                    }
                }
                HOperatorSet.WaitSeconds(0.01);
            }
            HOperatorSet.WaitSeconds(0.1);
            // dev_set_preferences(...); only in hdevelop
            ho_EmptyObject.Dispose();
            ho_Circle.Dispose();

            return;
        }

        static public void Subregion2(HObject ho_InputImage, HObject ho_InputRegion, ref HObject ho_OutputRegion,
   HTuple hv_Winhandle, HTuple hv_Linewidth, bool IsCircle = true, HObject originalContour = null)
        {



            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_Circle = null, ho_Rect = null;

            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            //  HOperatorSet.GenEmptyObj(out ho_OutputRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            //  ho_OutputRegion.Dispose();
            // HOperatorSet.GenEmptyRegion(out ho_OutputRegion);
            if ((int)(new HTuple(ho_InputRegion.TestEqualObj(ho_EmptyObject))) != 0)
            {
                ho_EmptyObject.Dispose();
                ho_Circle.Dispose();

                return;
            }
            ho_OutputRegion.Dispose();
            HOperatorSet.CopyObj(ho_InputRegion, out ho_OutputRegion, 1, 1);
            // dev_set_preferences(...); only in hdevelop
            HOperatorSet.SetColor(hv_Winhandle, "orange");
            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;

            while (isContinue_drawing)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if (isContinue_drawing)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;


                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);

                            HOperatorSet.Difference(ho_OutputRegion, ho_Circle, out ExpTmpOutVar_0);
                        }
                        else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                   hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);
                            HOperatorSet.Difference(ho_OutputRegion, ho_Rect, out ExpTmpOutVar_0);
                        }
                        ho_OutputRegion.Dispose();
                        ho_OutputRegion = ExpTmpOutVar_0;

                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_InputImage, hv_Winhandle);
                        if (ObjectValided(originalContour))
                        {
                            HOperatorSet.SetColor(hv_Winhandle, "green");
                            HOperatorSet.DispObj(originalContour, hv_Winhandle);
                        }
                        HOperatorSet.SetColor(hv_Winhandle, "orange");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_OutputRegion, hv_Winhandle);

                    }
                }
                HOperatorSet.WaitSeconds(0.01);
                System.Windows.Forms.Application.DoEvents();
            }
            //HOperatorSet.WaitSeconds(0.1);
            // dev_set_preferences(...); only in hdevelop
            ho_EmptyObject.Dispose();
            ho_Circle.Dispose();

            return;
        }

        static public void Subregion3(HObject ho_InputImage, HObject ho_InputRegion, ref HObject ho_OutputRegion,
HTuple hv_Winhandle, HTuple hv_Linewidth, bool IsCircle = true)
        {



            HSystem sys = new HSystem();

            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_Circle = null, ho_Rect = null;

            // Local control variables 

            HTuple hv_hv_Button = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            //  HOperatorSet.GenEmptyObj(out ho_OutputRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Rect);
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            //  ho_OutputRegion.Dispose();
            // HOperatorSet.GenEmptyRegion(out ho_OutputRegion);
            if ((int)(new HTuple(ho_InputRegion.TestEqualObj(ho_EmptyObject))) != 0)
            {
                ho_EmptyObject.Dispose();
                ho_Circle.Dispose();

                return;
            }
            ho_OutputRegion.Dispose();
            HOperatorSet.CopyObj(ho_InputRegion, out ho_OutputRegion, 1, 1);
            // dev_set_preferences(...); only in hdevelop
            HOperatorSet.SetColor(hv_Winhandle, "orange");
            HOperatorSet.SetSystem("flush_graphic", "true");
            hv_hv_Button = 0;

            while (isContinue_drawing)
            {
                // (dev_)set_check ("~give_error")
                try
                {
                    HOperatorSet.GetMposition(hv_Winhandle, out hv_Row, out hv_Column, out hv_hv_Button);
                }
                catch (HalconException e)
                {
                    int error = e.GetErrorCode();
                    if (error < 0)
                        throw e;
                }
                // (dev_)set_check ("give_error")
                if ((int)((new HTuple(hv_Row.TupleGreaterEqual(0))).TupleAnd(new HTuple(hv_Column.TupleGreater(
                    0)))) != 0)
                {
                    if (isContinue_drawing)
                    {
                        HOperatorSet.SetSystem("flush_graphic", "false");
                        HObject ExpTmpOutVar_0;


                        if (IsCircle)
                        {
                            ho_Circle.Dispose();
                            HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Linewidth);

                            HOperatorSet.Difference(ho_OutputRegion, ho_Circle, out ExpTmpOutVar_0);
                        }
                        else
                        {
                            ho_Rect.Dispose();
                            HOperatorSet.GenRectangle1(out ho_Rect, hv_Row - hv_Linewidth / 2, hv_Column - hv_Linewidth / 2,
                                   hv_Row + hv_Linewidth / 2, hv_Column + hv_Linewidth / 2);
                            HOperatorSet.Difference(ho_OutputRegion, ho_Rect, out ExpTmpOutVar_0);
                        }
                        ho_OutputRegion.Dispose();
                        ho_OutputRegion = ExpTmpOutVar_0;

                        HOperatorSet.ClearWindow(hv_Winhandle);
                        HOperatorSet.DispObj(ho_InputImage, hv_Winhandle);

                        HOperatorSet.SetColor(hv_Winhandle, "green");
                        HOperatorSet.SetSystem("flush_graphic", "true");
                        HOperatorSet.DispObj(ho_OutputRegion, hv_Winhandle);

                    }
                }
                HOperatorSet.WaitSeconds(0.01);
                System.Windows.Forms.Application.DoEvents();
            }
            //HOperatorSet.WaitSeconds(0.1);
            // dev_set_preferences(...); only in hdevelop
            ho_EmptyObject.Dispose();
            ho_Circle.Dispose();

            return;
        }
        // Local procedures 
        static public void select_xld_max(HObject ho_contours, out HObject ho_max_coutour)
        {

            // Local iconic variables 

            HObject ho_ObjectSelected = null, ho_EmptyObject = null;

            // Local control variables 

            HTuple hv_Number = null, hv_Index = new HTuple();
            HTuple hv_Length = new HTuple(), hv_Length1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_max_coutour);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            try
            {
                ho_max_coutour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_max_coutour);
                HOperatorSet.CountObj(ho_contours, out hv_Number);
                if ((int)(new HTuple(hv_Number.TupleLessEqual(0))) != 0)
                {
                    ho_ObjectSelected.Dispose();
                    ho_EmptyObject.Dispose();

                    return;
                }
                else
                {
                    HTuple end_val5 = hv_Number;
                    HTuple step_val5 = 1;
                    for (hv_Index = 1; hv_Index.Continue(end_val5, step_val5); hv_Index = hv_Index.TupleAdd(step_val5))
                    {
                        ho_ObjectSelected.Dispose();
                        HOperatorSet.SelectObj(ho_contours, out ho_ObjectSelected, hv_Index);
                        if ((int)(new HTuple(hv_Index.TupleEqual(1))) != 0)
                        {
                            ho_EmptyObject.Dispose();
                            HOperatorSet.CopyObj(ho_ObjectSelected, out ho_EmptyObject, 1, 1);
                            ho_max_coutour.Dispose();
                            HOperatorSet.CopyObj(ho_EmptyObject, out ho_max_coutour, 1, 1);
                            continue;
                        }
                        HOperatorSet.LengthXld(ho_ObjectSelected, out hv_Length);
                        HOperatorSet.LengthXld(ho_EmptyObject, out hv_Length1);
                        if ((int)(new HTuple(hv_Length.TupleGreaterEqual(hv_Length1))) != 0)
                        {
                            ho_max_coutour.Dispose();
                            HOperatorSet.CopyObj(ho_ObjectSelected, out ho_max_coutour, 1, 1);
                        }
                    }
                }


                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();

                throw HDevExpDefaultException;
            }
        }


        // Procedures 
        // Chapter: Filters / Arithmetic
        // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
        static public void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min,
            HTuple hv_Max)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_SelectedChannel = null, ho_LowerRegion = null;
            HObject ho_UpperRegion = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = ho_Image.CopyObj(1, -1);



            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = null, hv_Add = null, hv_Channels = null;
            HTuple hv_Index = null, hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            HTuple hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = hv_Max.Clone();
            HTuple hv_Min_COPY_INP_TMP = hv_Min.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            //Convenience procedure to scale the gray values of the
            //input image Image from the interval [Min,Max]
            //to the interval [0,255] (default).
            //Gray values < 0 or > 255 (after scaling) are clipped.
            //
            //If the image shall be scaled to an interval different from [0,255],
            //this can be achieved by passing tuples with 2 values [From, To]
            //as Min and Max.
            //Example:
            //scale_image_range(Image:ImageScaled:[100,50],[200,250])
            //maps the gray values of Image from the interval [100,200] to [50,250].
            //All other gray values will be clipped.
            //
            //input parameters:
            //Image: the input image
            //Min: the minimum gray value which will be mapped to 0
            //     If a tuple with two values is given, the first value will
            //     be mapped to the second value.
            //Max: The maximum gray value which will be mapped to 255
            //     If a tuple with two values is given, the first value will
            //     be mapped to the second value.
            //
            //output parameter:
            //ImageScale: the resulting scaled image
            //
            if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
                2))) != 0)
            {
                hv_LowerLimit = hv_Min_COPY_INP_TMP[1];
                hv_Min_COPY_INP_TMP = hv_Min_COPY_INP_TMP[0];
            }
            else
            {
                hv_LowerLimit = 0.0;
            }
            if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
                2))) != 0)
            {
                hv_UpperLimit = hv_Max_COPY_INP_TMP[1];
                hv_Max_COPY_INP_TMP = hv_Max_COPY_INP_TMP[0];
            }
            else
            {
                hv_UpperLimit = 255.0;
            }
            //
            //Calculate scaling parameters
            hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
            hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
            //
            //Scale image
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, hv_Add);
                ho_Image_COPY_INP_TMP.Dispose();
                ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            //
            //Clip gray values if necessary
            //This must be done for each channel separately
            HOperatorSet.CountChannels(ho_Image_COPY_INP_TMP, out hv_Channels);
            HTuple end_val48 = hv_Channels;
            HTuple step_val48 = 1;
            for (hv_Index = 1; hv_Index.Continue(end_val48, step_val48); hv_Index = hv_Index.TupleAdd(step_val48))
            {
                ho_SelectedChannel.Dispose();
                HOperatorSet.AccessChannel(ho_Image_COPY_INP_TMP, out ho_SelectedChannel, hv_Index);
                HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray,
                    out hv_MaxGray, out hv_Range);
                ho_LowerRegion.Dispose();
                HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
                    hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                ho_UpperRegion.Dispose();
                HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                    ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                        hv_LowerLimit, "fill");
                    ho_SelectedChannel.Dispose();
                    ho_SelectedChannel = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                        hv_UpperLimit, "fill");
                    ho_SelectedChannel.Dispose();
                    ho_SelectedChannel = ExpTmpOutVar_0;
                }
                if ((int)(new HTuple(hv_Index.TupleEqual(1))) != 0)
                {
                    ho_ImageScaled.Dispose();
                    HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageScaled, 1, 1);
                }
                else
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AppendChannel(ho_ImageScaled, ho_SelectedChannel, out ExpTmpOutVar_0
                            );
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
            }
            ho_Image_COPY_INP_TMP.Dispose();
            ho_SelectedChannel.Dispose();
            ho_LowerRegion.Dispose();
            ho_UpperRegion.Dispose();

            return;
        }


        /// <summary>
        ///  
        /// </summary>
        /// <param name="ho_Image"></param>
        /// <param name="hv_min"></param>
        /// <param name="hv_max"></param>
        /// <returns></returns>
        static public HObject Img_Enhancement_processing(HObject ho_Image, variableSetParmas dparmas)
        {
            try
            {
                HObject imageScaleMax = null;
                HObject imageScaled = null;
                HOperatorSet.GenEmptyObj(out imageScaleMax);
                HOperatorSet.GenEmptyObj(out imageScaled);
                imageScaleMax.Dispose();
                HOperatorSet.ScaleImageMax(ho_Image, out imageScaleMax);
                imageScaled.Dispose();
                scale_image_range(imageScaleMax, out imageScaled, dparmas.Scale_range_min, dparmas.Scale_range_max);

                imageScaleMax.Dispose();
                return imageScaled;
            }
            catch
            { return null; }


        }
        //
        public static SetModelROIData SetModelROI(HTuple hwindhanle, HObject ho_Image)
        {
            SetModelROIData _setModelROIData = new SetModelROIData();

            HObject ho_Rectangle = null;
            HObject ho_ImageReduced3 = null;
            HObject ho_Region = null, connectedRegions = null, ho_SelectedRegions = null;
            HObject regionFillUp = null, cross = null;
            //HObject ho_RegionErosion = null;
            HTuple hv_UsedThreshold;
            try
            {
                HOperatorSet.GenEmptyObj( out ho_Rectangle);
                HOperatorSet.GenEmptyObj(out ho_ImageReduced3);
                HOperatorSet.GenEmptyObj(out ho_Region);
                HOperatorSet.GenEmptyObj(out connectedRegions);
                HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
                //HOperatorSet.GenEmptyObj(out ho_RegionErosion);
                HOperatorSet.GenEmptyObj(out regionFillUp);
                HOperatorSet.GenEmptyObj(out cross);
                HOperatorSet.GenEmptyObj(out _setModelROIData.modelSearchROI);

                HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple(), hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
                HOperatorSet.DrawRectangle1(hwindhanle, out hv_Row1, out hv_Column1, out hv_Row2,
                   out hv_Column2);
                ho_Rectangle.Dispose();
                HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2,
                    hv_Column2);
                _setModelROIData.modelSearchROI.Dispose();
                HOperatorSet.CopyObj(ho_Rectangle, out _setModelROIData.modelSearchROI, 1, 1);

                ho_ImageReduced3.Dispose();
                HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced3);
                ho_Region.Dispose();
                HOperatorSet.BinaryThreshold(ho_ImageReduced3, out ho_Region, "max_separability",
        "light", out hv_UsedThreshold);
                connectedRegions.Dispose();
                HOperatorSet.Connection(ho_Region, out connectedRegions);
                ho_SelectedRegions.Dispose();
                HOperatorSet.SelectShapeStd(connectedRegions, out ho_SelectedRegions, "max_area",
        70);
                //ho_RegionErosion.Dispose();
                //HOperatorSet.ErosionCircle(ho_SelectedRegions, out ho_RegionErosion, 3.5);

                HOperatorSet.ClosingCircle(ho_SelectedRegions, out HObject regionClosing, 3.5);

                regionFillUp.Dispose();
                HOperatorSet.FillUp(regionClosing, out regionFillUp);
                HTuple area, row, column;
                HOperatorSet.AreaCenter(regionFillUp, out area, out row, out column);
                if (row != null)
                {
                    HOperatorSet.GenEmptyObj(out cross);
                    cross.Dispose();

                    HOperatorSet.GenCrossContourXld(out cross, row, column, 1000, 0);

                    HOperatorSet.DispObj(cross, hwindhanle);
                }

                HTuple rowx = new HTuple(), columnx = new HTuple();
                if (hwindhanle.D > 100000)
                    HOperatorSet.SetFont(hwindhanle, "Arial-" + "12");
                else
                    HOperatorSet.SetFont(hwindhanle, "-Arial-" + "12" + "-*-*-*-*-1-");
                disp_message(hwindhanle, "",
                    "image", row - 100, column, "red", "false");

                HOperatorSet.SetColor(hwindhanle, "orange");
                HOperatorSet.DrawPointMod(hwindhanle, row, column, out rowx, out columnx);
                _setModelROIData.modelOrigionRow = rowx;
                _setModelROIData.modelOrigionColumn = columnx;
                //HOperatorSet.DrawPoint(hwindhanle, out rowx, out columnx);
                //HOperatorSet.SetShapeModelOrigin(temmodelMatchStruct.hv_ModelID1, rowx - hv_Row3, columnx - hv_Column3);
            }
            catch (Exception er)
            {
                ho_Rectangle.Dispose();
                ho_ImageReduced3.Dispose();
                ho_Region.Dispose();
                connectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
                //ho_RegionErosion.Dispose();
                regionFillUp.Dispose();
                cross.Dispose();
                return null;

            }

            finally
            {
                ho_Rectangle.Dispose();
                ho_ImageReduced3.Dispose();
                ho_Region.Dispose();
                connectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
                //ho_RegionErosion.Dispose();
                regionFillUp.Dispose();
                cross.Dispose();
              
            }
            return _setModelROIData;
        }

       /// <summary>
       /// 
       /// </summary>
       /// <param name="ho_Arrow"></param>
       /// <param name="hv_Row1"></param>
       /// <param name="hv_Column1"></param>
       /// <param name="hv_Row2"></param>
       /// <param name="hv_Column2"></param>
       /// <param name="hv_HeadLength"></param>
       /// <param name="hv_HeadWidth"></param>
        static void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
             HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = null, hv_ZeroLengthIndices = null;
            HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
            HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
            HTuple hv_ColP2 = null, hv_Index = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            //This procedure generates arrow shaped XLD contours,
            //pointing from (Row1, Column1) to (Row2, Column2).
            //If starting and end point are identical, a contour consisting
            //of a single point is returned.
            //
            //input parameteres:
            //Row1, Column1: Coordinates of the arrows' starting points
            //Row2, Column2: Coordinates of the arrows' end points
            //HeadLength, HeadWidth: Size of the arrow heads in pixels
            //
            //output parameter:
            //Arrow: The resulting XLD contour
            //
            //The input tuples Row1, Column1, Row2, and Column2 have to be of
            //the same length.
            //HeadLength and HeadWidth either have to be of the same length as
            //Row1, Column1, Row2, and Column2 or have to be a single element.
            //If one of the above restrictions is violated, an error will occur.
            //
            //
            //Init
            ho_Arrow.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            //
            //Calculate the arrow length
            HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
            //
            //Mark arrows with identical start and end point
            //(set Length to -1 to avoid division-by-zero exception)
            hv_ZeroLengthIndices = hv_Length.TupleFind(0);
            if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
            {
                if (hv_Length == null)
                    hv_Length = new HTuple();
                hv_Length[hv_ZeroLengthIndices] = -1;
            }
            //
            //Calculate auxiliary variables.
            hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
            hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
            hv_HalfHeadWidth = hv_HeadWidth / 2.0;
            //
            //Calculate end points of the arrow head.
            hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
            hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
            hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
            hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
            //
            //Finally create output XLD contour for each input point pair
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                {
                    //Create_ single points for arrows with identical start and end point
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(hv_Index),
                        hv_Column1.TupleSelect(hv_Index));
                }
                else
                {
                    //Create arrow contour
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                        hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                        ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                        hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                    ho_Arrow.Dispose();
                    ho_Arrow = ExpTmpOutVar_0;
                }
            }
            ho_TempArrow.Dispose();

            return;
        }



        public static List<HObject> CreateSys(HObject ho_Image,HTuple HomMat2D)
        {
            HTuple hv_Width, hv_Height;
            HTuple hv_HomMat2D2, hv_HomMat2D;       
          
            HObject ho_ContoursAffineTrans = null, ho_ContoursAffineTrans2 = null;
            HObject ho_ContoursAffineTrans1 = null, ho_ContoursAffineTrans3 = null;
            
           // HTuple hv_Row2, hv_Column2, hv_IsOverlapping;

            HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans);
            HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans2);
            HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans1);
            HOperatorSet.GenEmptyObj(out ho_ContoursAffineTrans3);
           

            List<HObject> arrowList = new List<HObject>();
            try
            {
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                //HOperatorSet.HomMat2dInvert(HomMat2D, out hv_HomMat2DInvert);
                HOperatorSet.HomMat2dToAffinePar(HomMat2D, out HTuple sx, out HTuple sy, out HTuple phi, out HTuple theta, out HTuple tx, out HTuple ty);
                int ratio = hv_Width.I / 1000;
                if (ratio < 1) ratio = 1;
                //HOperatorSet.SetColor(hwindhanle, "red");
                //gen_contour_polygon_xld (Contour, [0,0], [0,10])
                //ho_Arrow.Dispose();
                //gen_arrow_contour_xld(out ho_Arrow, 0, -10* ratio, 0, 100* ratio, 10* ratio, 10* ratio);

                //HOperatorSet.SetColor(hwindhanle, "green");         
                //gen_contour_polygon_xld (Contour1, [0,10], [0,0])
                //ho_Arrow1.Dispose();
                //gen_arrow_contour_xld(out ho_Arrow1, -10 * ratio, 0,100 * ratio, 0,10 * ratio, 10 * ratio);
                //concat_obj (Contour, Contour1, ObjectsConcat)

                //HOperatorSet.SetColor(hwindhanle, "red");
                HOperatorSet.AffineTransPoint2d(HomMat2D, -10, 0, out HTuple hv_Qx, out HTuple hv_Qy);
                HOperatorSet.AffineTransPoint2d(HomMat2D, 100, 0, out HTuple hv_Qx1, out HTuple hv_Qy1);
                gen_arrow_contour_xld(out HObject Arrow2, hv_Qy, hv_Qx, hv_Qy1, hv_Qx1, 10 * sx, 10 * sx);
                //HOperatorSet.SetColor(hwindhanle, "green");  
                HOperatorSet.AffineTransPoint2d(HomMat2D, 0, -10, out HTuple hv_Qx2, out HTuple hv_Qy2);
                HOperatorSet.AffineTransPoint2d(HomMat2D, 0, 100, out HTuple hv_Qx3, out HTuple hv_Qy3);
                gen_arrow_contour_xld(out HObject Arrow3, hv_Qy2, hv_Qx2, hv_Qy3, hv_Qx3, 10 * sx, 10 * sx);
                //
                HOperatorSet.AffineTransPoint2d(HomMat2D, 0, 0, out HTuple hv_Qx4, out HTuple hv_Qy4);
                HOperatorSet.VectorAngleToRigid(hv_Qy4, hv_Qx4, 0, 0,0, 0, out hv_HomMat2D);
                HOperatorSet.HomMat2dScale(hv_HomMat2D, 1/ sx,1/ sx, 0, 0, out HTuple homMat2DScale);

                //HOperatorSet.SetColor(hwindhanle, "red");
                ho_ContoursAffineTrans.Dispose();
                HOperatorSet.AffineTransContourXld(Arrow2, out ho_ContoursAffineTrans, homMat2DScale);
                //HOperatorSet.SetColor(hwindhanle, "green");  
                ho_ContoursAffineTrans1.Dispose();
                HOperatorSet.AffineTransContourXld(Arrow3, out ho_ContoursAffineTrans1, homMat2DScale);

                //HOperatorSet.VectorAngleToRigid(0, 0, 0, 100 * ratio, hv_Width- 120 * ratio, 0, out hv_HomMat2D2);

                HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Height - 200 * ratio, 100 * ratio, 0, out hv_HomMat2D2);

                //HOperatorSet.SetColor(hwindhanle, "red");
                ho_ContoursAffineTrans2.Dispose();
                HOperatorSet.AffineTransContourXld(ho_ContoursAffineTrans, out ho_ContoursAffineTrans2,
                    hv_HomMat2D2);

                //HOperatorSet.SetColor(hwindhanle, "green"); 
                ho_ContoursAffineTrans3.Dispose();
                HOperatorSet.AffineTransContourXld(ho_ContoursAffineTrans1, out ho_ContoursAffineTrans3,
                    hv_HomMat2D2);


                arrowList.Add(ho_ContoursAffineTrans2);
                arrowList.Add(ho_ContoursAffineTrans3);


            }
            catch (Exception er)
            {
              
                ho_ContoursAffineTrans.Dispose();
                ho_ContoursAffineTrans1.Dispose();
         
                return null;
            }
          
            ho_ContoursAffineTrans.Dispose();
            ho_ContoursAffineTrans1.Dispose();
         
            return arrowList;
        }



        //
        public static HObject CreateModel(HTuple hwindhanle, HObject ho_Image,HObject modelSearchROI,
                      SetModelROIData _setModelROIData, variableSetParmas dparmas,
                      ref ModelMatchStruct temmodelMatchStruct,ref  string errmsg)
        {

            HObject modelContourAffine = null;
            HObject ho_ImageReduced = null;
            //HObject ho_ImageReduced2 = null;
            //HObject ho_ModelImages = null, ho_ModelRegions = null;
            HObject ho_ModelContours = null, ho_Contours = null;
         
            //  HTuple hv_ModelID;
               HTuple hv_Row3; HTuple hv_Column3;
                HTuple hv_Row3_convert = new HTuple(); HTuple hv_Column3_convert = new HTuple();

                HTuple hv_Angle;
                HTuple hv_Scale; HTuple hv_Score;

               HOperatorSet.GenEmptyObj(out ho_ImageReduced);
          //  HOperatorSet.GenEmptyObj(out ho_ImageReduced2);
            HOperatorSet.GenEmptyObj(out ho_ModelContours);
               HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out modelContourAffine);

            try
            {
              
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_Image, modelSearchROI, out ho_ImageReduced
                    );
              

                //
                HOperatorSet.CreateScaledShapeModel(ho_ImageReduced, "auto", dparmas.StartAngle.TupleRad()
                    , dparmas.RangeAngle.TupleRad(), "auto", dparmas.scaleDownLimit, dparmas.scaleUpLimit, "auto", "auto", "use_polarity",
                  dparmas.MatchContrast.I, "auto", out temmodelMatchStruct.hv_ModelID1);


                /******************/

                //HOperatorSet.CreateShapeModel(ho_ImageReduced, "auto", dparmas.StartAngle.TupleRad()
                //          , endAngle.TupleRad() * 2, "auto", "auto", "use_polarity",
                //                     dparmas.MatchContrast.I, "auto", out temmodelMatchStruct.hv_ModelID1);

                //  ho_ImageReduced2.Dispose();
                //HOperatorSet.ReduceDomain(ho_Image, _setModelROIData.modelSearchROI, out ho_ImageReduced2
                //    );

                //HOperatorSet.WriteShapeModel(temmodelMatchStruct.hv_ModelID1,"11222.shm");

                HOperatorSet.ReduceDomain(ho_Image, _setModelROIData.modelSearchROI, out HObject imageReduced);
            
                HOperatorSet.FindScaledShapeModel(imageReduced, temmodelMatchStruct.hv_ModelID1,0
                    , 0, 1, 1, dparmas.matchScore, 1, 0.5, "least_squares",
                    0, 0.9, out hv_Row3, out hv_Column3, out hv_Angle, out hv_Scale, out hv_Score);

                //HOperatorSet.InspectShapeModel()
                //HOperatorSet.FindShapeModel(ho_Image, temmodelMatchStruct.hv_ModelID1, dparmas.StartAngle.TupleRad()
                // , endAngle.TupleRad() * 2, dparmas.matchScore, 1, 0.5, "least_squares",
                // 0, dparmas.greedValue, out hv_Row3, out hv_Column3, out hv_Angle, out hv_Score);

                //Task.Factory.StartNew(() => {
                //    HOperatorSet.WriteImage(ho_Image, "bmp", 255, "D:\\imgSave.bmp");
                //});
                if (hv_Score.Length == 1)
                {                
                    //HOperatorSet.DrawPoint(hwindhanle, out rowx, out columnx);
                    HOperatorSet.SetShapeModelOrigin(temmodelMatchStruct.hv_ModelID1, _setModelROIData.modelOrigionRow - hv_Row3,
                                _setModelROIData.modelOrigionColumn  - hv_Column3);
                }
                //------------------------------------  
                HOperatorSet.FindScaledShapeModel(imageReduced, temmodelMatchStruct.hv_ModelID1, 0
                   ,0, 1, 1, dparmas.matchScore, 1, 0.5, "least_squares",
                   0, 0.9, out hv_Row3, out hv_Column3, out hv_Angle, out hv_Scale, out hv_Score);
                //HOperatorSet.FindShapeModel(ho_Image, temmodelMatchStruct.hv_ModelID1, dparmas.StartAngle.TupleRad()
                // , endAngle.TupleRad() * 2, dparmas.matchScore, 1, 0.5, "least_squares",
                // 0, dparmas.greedValue, out hv_Row3, out hv_Column3, out hv_Angle, out hv_Score); 
                if (hv_Score.Length == 1)
                {

                    HTuple hv_HomMat2D = new HTuple(), hv_HomMat2DScale = new HTuple();
                    HOperatorSet.VectorAngleToRigid(0,
                                      0,
                                      0, hv_Row3.TupleSelect(0), hv_Column3.TupleSelect(0),
                                      hv_Angle.TupleSelect(0), out hv_HomMat2D);

                    HOperatorSet.HomMat2dScale(hv_HomMat2D, hv_Scale.TupleSelect(0), hv_Scale.TupleSelect(0),
                        hv_Row3.TupleSelect(0), hv_Column3.TupleSelect(0), out hv_HomMat2DScale);
                    //HOperatorSet.HomMat2dScale(hv_HomMat2D, 1, 1,
                    //   hv_Row3.TupleSelect(0), hv_Column3.TupleSelect(0), out hv_HomMat2DScale);
                    ho_Contours.Dispose();
                    HOperatorSet.GetShapeModelContours(out ho_Contours, temmodelMatchStruct.hv_ModelID1, 1);
                   
                    modelContourAffine.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_Contours,
                               out modelContourAffine, hv_HomMat2DScale);
                    //HOperatorSet.SetColor(hwindhanle, "green");
                    //HOperatorSet.DispObj(modelContourAffine, hwindhanle);

                    HOperatorSet.AffineTransPixel(hv_HomMat2DScale, 0, 0,
                        out hv_Row3_convert, out hv_Column3_convert);
                    //HObject temcross = new HObject();
                    //temcross.Dispose();
                    //HOperatorSet.GenCrossContourXld(out temcross, hv_Row3_convert, hv_Column3_convert, 100, 0);
                    //HOperatorSet.DispObj(temcross, hwindhanle);
                    temmodelMatchStruct.basepoint_Tuple = new HTuple();
                    temmodelMatchStruct.basepoint_Tuple[0] = hv_Row3_convert;
                    temmodelMatchStruct.basepoint_Tuple[1] = hv_Column3_convert;
                }
                //temmodelMatchStruct.hv_ModelID1 = hv_ModelID;
                //temmodelMatchStruct.ModelOrigin_Tuple[0] = hv_Row;
                //temmodelMatchStruct.ModelOrigin_Tuple[1] = hv_Column;
              
            }

            catch (Exception er)
            {
                errmsg = er.Message;
                return null;
            }
            finally
            {                          
                ho_ImageReduced.Dispose();
                ho_ModelContours.Dispose();         
                ho_Contours.Dispose();
             
            }
            return modelContourAffine;
        }

        //
        public static bool SaveModelFile(ModelMatchStruct temmodelMatchStruct,string basedir = "modelfile\\ProductModel")
        {
           
            int index= basedir.LastIndexOf('\\');
            string m_path = basedir.Substring(0, index);
            //if (!Directory.Exists("modelfile"))
            //    Directory.CreateDirectory("modelfile");
            if (!Directory.Exists(m_path))
                Directory.CreateDirectory(m_path);
            if (!Directory.Exists(basedir))
                 Directory.CreateDirectory(basedir);
            try
            {
                HTuple hv_basepoint = new HTuple();
                hv_basepoint = ((hv_basepoint.TupleConcat(temmodelMatchStruct.basepoint_Tuple.TupleSelect(0)))).TupleConcat(
                    temmodelMatchStruct.basepoint_Tuple.TupleSelect(1));
                HOperatorSet.WriteTuple(hv_basepoint, basedir + "\\basepoint.tup");
                HOperatorSet.WriteShapeModel(temmodelMatchStruct.hv_ModelID1, basedir + "\\shapemodel1.shm");
                //if (GuidePositioning_HDevelopExport.ObjectValided(temmodelMatchStruct.modelregion))
                //    HOperatorSet.WriteRegion(temmodelMatchStruct.modelregion, basedir + "\\modelregion.reg");
                //HOperatorSet.ClearShapeModel(temmodelMatchStruct.hv_ModelID1);
                return true;
            }
            catch (Exception er) { return false; }

        }
        //
        public static void ReadModleFile(string filepath,ref ModelMatchStruct modelMatchStructData
                   )
        {
                 
            try
            {
     
                HOperatorSet.ReadShapeModel(filepath, out modelMatchStructData.hv_ModelID1);                         

            }
            catch (HalconException er) { }


        }

        //
        public static bool ReadModleFile(ref ModelMatchStruct modelMatchStructData,
                 ref string msg,  string basedir = "modelfile\\ProductModel")
        {
           
            //modelMatchStruct modelMatchStructData = new modelMatchStruct();

            HTuple hv_Row6 = new HTuple(), hv_Column6 = new HTuple();
           
         
            try
            {
              ;
                // HOperatorSet.ReadShapeModel("shapemodel1.shm", out modelMatchStructData.hv_ModelID1);
                if(!File.Exists(basedir + "\\shapemodel1.shm"))
                {
                    msg += "";
                    return false;
                }
                HOperatorSet.ReadShapeModel(basedir + "\\shapemodel1.shm", out modelMatchStructData.hv_ModelID1);
                //HOperatorSet.ReadTuple("basepoint.tup", out modelMatchStructData.basepoint_Tuple);
               if(basedir.Contains("modelfile"))
                  HOperatorSet.ReadTuple(basedir + "\\basepoint.tup", out modelMatchStructData.basepoint_Tuple);
                HOperatorSet.GetShapeModelOrigin(modelMatchStructData.hv_ModelID1, out hv_Row6, out hv_Column6);
                //modelMatchStructData.ModelOrigin_Tuple[0] = hv_Row6;
                //modelMatchStructData.ModelOrigin_Tuple[1] = hv_Column6;
                //if (File.Exists(basedir + "\\modelregion.reg"))
                //    HOperatorSet.ReadRegion(out modelMatchStructData.modelregion, basedir + "\\modelregion.reg");
                return true;
            }
            catch (HalconException er) {
                msg += er.Message;
                return false;
            }     
        }
        //
        public static bool Set_P_N_inspectArea(HTuple hwindhanle, out HObject ho_Region3)
        {
            HObject ho_PolygonRegion = null, ho_Skeleton1 = null, ho_Contours2 = null;
            HObject ho_max_coutour = null;
            HOperatorSet.GenEmptyObj(out ho_PolygonRegion);
            HOperatorSet.GenEmptyObj(out ho_Skeleton1);
            HOperatorSet.GenEmptyObj(out ho_Contours2);
            HOperatorSet.GenEmptyObj(out ho_max_coutour);

            HTuple hv_Row8 = new HTuple(); HTuple hv_Col8 = new HTuple();

            try
            {
                ho_PolygonRegion.Dispose();
                HOperatorSet.DrawPolygon(out ho_PolygonRegion, hwindhanle);
                ho_Skeleton1.Dispose();
                HOperatorSet.Skeleton(ho_PolygonRegion, out ho_Skeleton1);
                ho_Contours2.Dispose();
                HOperatorSet.GenContoursSkeletonXld(ho_Skeleton1, out ho_Contours2, 1, "filter");
                ho_max_coutour.Dispose();
                select_xld_max(ho_Contours2, out ho_max_coutour);
                HOperatorSet.GetContourXld(ho_max_coutour, out hv_Row8, out hv_Col8);

                HOperatorSet.GenRegionPolygonFilled(out ho_Region3, hv_Row8.TupleConcat(hv_Row8.TupleSelect(
                    0)), hv_Col8.TupleConcat(hv_Col8.TupleSelect(0)));

            }
            catch { ho_Region3 = null; return false; }

            ho_PolygonRegion.Dispose();
            ho_Skeleton1.Dispose();
            ho_Contours2.Dispose();
           
            ho_max_coutour.Dispose();
            return true;
        }
        //
        public static void Save_P_N_inspectAreaFile(HObject saveRegion)
        {
            HOperatorSet.WriteRegion(saveRegion, AppDomain.CurrentDomain.BaseDirectory + "PolygonRegion1.reg");
        }
        //
        public static void Read_P_N_inspectAreaFile(out HObject ho_Region2)
        {
            string path = AppDomain.CurrentDomain.BaseDirectory + "PolygonRegion1.reg";
            if (!File.Exists(path))
            {
                ho_Region2 = null;
                return;
            }
               
            HOperatorSet.GenEmptyObj(out ho_Region2);
            ho_Region2.Dispose();
            //HOperatorSet.ReadRegion(out ho_Region2, "PolygonRegion1.reg");
            HOperatorSet.ReadRegion(out ho_Region2, AppDomain.CurrentDomain.BaseDirectory + "PolygonRegion1.reg");
        }
        //
        public static void Transformation_matrix(HTuple hv_PixelPointx, HTuple hv_PixelPointy,
                   HTuple hv_MechinePointX, HTuple hv_MechinePointY, out HTuple hv_HomMat2D,out HTuple pararray)
        {

            hv_HomMat2D = null;
            pararray =new HTuple();
            try
            {
                #region
                ////////columns
                //hv_PixelPointx = new HTuple();
                //hv_PixelPointx[0] = 1639.86;
                //hv_PixelPointx[1] = 2525.64;
                //hv_PixelPointx[2] = 3278.83;
                //hv_PixelPointx[3] = 3274.81;
                //hv_PixelPointx[4] = 2599.94;
                //hv_PixelPointx[5] = 1662.59;
                //hv_PixelPointx[6] = 1654.87;
                //hv_PixelPointx[7] = 2505.68;
                //hv_PixelPointx[8] = 3524.28;
                ////////rows
                //hv_PixelPointy = new HTuple();
                //hv_PixelPointy[0] = 879.409;
                //hv_PixelPointy[1] = 887.377;
                //hv_PixelPointy[2] = 895.95;
                //hv_PixelPointy[3] = 1388.36;
                //hv_PixelPointy[4] = 1380.97;
                //hv_PixelPointy[5] = 1371.66;
                //hv_PixelPointy[6] = 1887.52;
                //hv_PixelPointy[7] = 1899.27;
                //hv_PixelPointy[8] = 1909.93;
                //hv_MechinePointX = new HTuple();
                //hv_MechinePointX[0] = -43.64;
                //hv_MechinePointX[1] = -23.52;
                //hv_MechinePointX[2] = -6.43;
                //hv_MechinePointX[3] = -6.43;
                //hv_MechinePointX[4] = -21.7;
                //hv_MechinePointX[5] = -42.95;
                //hv_MechinePointX[6] = -42.95;
                //hv_MechinePointX[7] = -23.51;
                //hv_MechinePointX[8] = -0.5;
                //hv_MechinePointY = new HTuple();
                //hv_MechinePointY[0] = -98.4;
                //hv_MechinePointY[1] = -98.4;
                //hv_MechinePointY[2] = -98.4;
                //hv_MechinePointY[3] = -87.18;
                //hv_MechinePointY[4] = -87.18;
                //hv_MechinePointY[5] = -87.18;
                //hv_MechinePointY[6] = -75.48;
                //hv_MechinePointY[7] = -75.48;
                //hv_MechinePointY[8] = -75.48;
                #endregion
                //////////
                HOperatorSet.VectorToHomMat2d(hv_PixelPointx, hv_PixelPointy, hv_MechinePointX,
                    hv_MechinePointY, out hv_HomMat2D);
                //hom_mat2d_translate (HomMat2D, -0.05, 0, HomMat2DTmp)
              
                HTuple sx = null, sy = null, phi = null, theta = null, tx = null, ty = null;
                HOperatorSet.HomMat2dToAffinePar(hv_HomMat2D,out sx,out sy,out phi,
                     out theta, out tx,out ty);
                pararray[0] = sx;
                pararray[1] = sy;
                pararray[2] = phi;
                pararray[3] = theta;
                pararray[4] = tx;
                pararray[5] = ty;

            }
            catch { }
        }

        //
        public static void Transformation_POINT(HTuple hv_HomMat2D, HTuple hv_x, HTuple hv_y,
                          out HTuple hv_Qx, out HTuple hv_Qy)
        {
            HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_x, hv_y, out hv_Qx, out hv_Qy);

            //HOperatorSet.AffineTransPixel(hv_HomMat2D, hv_x, hv_y, out hv_Qx, out hv_Qy);
        }

        //
        public static bool ModelMatchActive(HObject ho_Image, ModelMatchStruct temmodelMatchStruct,
                     variableSetParmas dparmas, ref outputResultStruct outputResultStructData)
        {

          
            HTuple hv_Row5 = null, hv_Column5 = null, hv_Angle1 = null, hv_Scale1 = null, hv_Score1 = null;
            HTuple hv_HomMat2D = null, hv_HomMat2DScale = null, hv_HomMat2D1 = null;
           
            HObject ho_ContoursAffinTrans =new HObject();
            HObject  ho_Cross =new HObject(); HObject ho_Contours = new HObject();

            outputResultStructData.ho_ContoursAffinTransList.Clear();
            outputResultStructData.ho_RegionAffineTransList.Clear();
            outputResultStructData.ho_CrossList.Clear();
            try
            {
               
                HOperatorSet.FindScaledShapeModel(ho_Image, temmodelMatchStruct.hv_ModelID1, dparmas.StartAngle.TupleRad()
                , dparmas.RangeAngle.TupleRad(), dparmas.scaleDownLimit, dparmas.scaleUpLimit, dparmas.matchScore, dparmas.matchNumber, 0.5, "least_squares",
                0, 0.9, out hv_Row5, out hv_Column5, out hv_Angle1, out hv_Scale1, out hv_Score1);
                //    HOperatorSet.FindShapeModel(ho_Image, temmodelMatchStruct.hv_ModelID1, dparmas.StartAngle.TupleRad()
                //, endAngle.TupleRad() * 2, dparmas.matchScore, dparmas.matchNumber, 0.5, "least_squares",
                //0, dparmas.greedValue, out hv_Row5, out hv_Column5, out hv_Angle1, out hv_Score1);

                if (hv_Score1.Length <= 0)
                {
                    outputResultStructData.runstatusFlag = false;
                    return false;    //
                }

                outputResultStructData.pixelrow = hv_Row5;
                outputResultStructData.pixelcolumn = hv_Column5;
                outputResultStructData.angle = hv_Angle1;
                outputResultStructData.hv_Score1 = hv_Score1;

                for (int i = 0; i < hv_Score1.Length; i++)
                {
                    HOperatorSet.VectorAngleToRigid(0,
                                    0,
                                    0, hv_Row5.TupleSelect(i), hv_Column5.TupleSelect(i), 
                                    hv_Angle1.TupleSelect(i), out hv_HomMat2D);

                    HOperatorSet.HomMat2dScale(hv_HomMat2D, hv_Scale1.TupleSelect(i), hv_Scale1.TupleSelect(i),
                        hv_Row5.TupleSelect(i), hv_Column5.TupleSelect(i), out hv_HomMat2DScale);
                    //HOperatorSet.HomMat2dScale(hv_HomMat2D, 1, 1,
                    //  hv_Row5.TupleSelect(i), hv_Column5.TupleSelect(i), out hv_HomMat2DScale);

                    ho_Contours.Dispose();
                    HOperatorSet.GetShapeModelContours(out ho_Contours, temmodelMatchStruct.hv_ModelID1, 1);
                 

                    HOperatorSet.AffineTransContourXld(ho_Contours,
                               out ho_ContoursAffinTrans, hv_HomMat2DScale);

                  
                    HTuple temhv_Row = new HTuple(), temhv_Column = new HTuple();
                    HOperatorSet.AffineTransPixel(hv_HomMat2DScale,0,
                                   0,
                                    out temhv_Row, out temhv_Column);
                    outputResultStructData.pixelrow[i] = temhv_Row;
                    outputResultStructData.pixelcolumn[i] = temhv_Column;
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, temhv_Row, temhv_Column,
                        200, hv_Angle1.TupleSelect(i));

                    HObject temobj = new HObject();
                    temobj.Dispose();
                    HOperatorSet.CopyObj(ho_ContoursAffinTrans, out temobj,
                       1, -1);
                    outputResultStructData.ho_ContoursAffinTransList.Add(temobj);             
                    ho_ContoursAffinTrans.Dispose();

                    HObject temobj2 = new HObject();
                    temobj2.Dispose();                 
                    HOperatorSet.CopyObj(ho_Cross, out temobj2, 1, 1);
                    outputResultStructData.ho_CrossList.Add(temobj2);
                    ho_Cross.Dispose();           
                   
                }                          
            }
            catch(Exception ER)
            {
                outputResultStructData.runstatusFlag = false;             
                ho_ContoursAffinTrans.Dispose();
                ho_Cross.Dispose();
                ho_Contours.Dispose();
              
                return false;
            }         
            ho_ContoursAffinTrans.Dispose();
            ho_Cross.Dispose();
            ho_Contours.Dispose();        
            outputResultStructData.runstatusFlag = true;
            return true;
        }

        //

        public static outputResultStruct ActinCheck(HObject ho_Image,ModelMatchStruct temmodelMatchStruct,
                      variableSetParmas dparmas, HTuple hv_point_HomMat2D,  producParma dproducParma)
        {

            outputResultStruct outputResultStructData = new outputResultStruct(true);
           
            //
            bool modelMatchFlag = ModelMatchActive(ho_Image, temmodelMatchStruct, dparmas,ref outputResultStructData);
            if (!modelMatchFlag)//
            {
                outputResultStructData.runstatusFlag = false;
                return outputResultStructData;
            }
         
             //
             HTuple hv_Qx = 0, hv_Qy = 0;
            Transformation_POINT(hv_point_HomMat2D, outputResultStructData.pixelcolumn,
                outputResultStructData.pixelrow, out hv_Qx, out hv_Qy);
            outputResultStructData.machine_X = hv_Qx;
            outputResultStructData.machine_Y = hv_Qy;
            outputResultStructData.runstatusFlag = true;
            return outputResultStructData;
        }


        public static bool IsClosedToTargetOBJ( HObject img,  HObject modelregion, variableSetParmas dparmas,
             HObject Searchregion)
        {
            
            HObject regionDifference = null;
            HObject imageReduced = null;
            HObject FastThresholdregion = null;
            HObject connectedRegions = null;
            HObject ho_SelectedRegions = null;

            HTuple area,  row,  column;
           
            HOperatorSet.GenEmptyObj(out regionDifference);
            HOperatorSet.GenEmptyObj(out imageReduced);
            HOperatorSet.GenEmptyObj(out FastThresholdregion);
            HOperatorSet.GenEmptyObj(out connectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);

            try
            {

           
                regionDifference.Dispose();
                HOperatorSet.Difference(Searchregion, modelregion, out regionDifference);

                imageReduced.Dispose();
                HOperatorSet.ReduceDomain(img, regionDifference, out imageReduced);
                FastThresholdregion.Dispose();

                HOperatorSet.Threshold(imageReduced, out FastThresholdregion,
                       dparmas.ThreshDownLimit, dparmas.ThreshUpLimit);
               
                connectedRegions.Dispose();
                HOperatorSet.Connection(FastThresholdregion, out connectedRegions);
                ho_SelectedRegions.Dispose();
                HOperatorSet.SelectShapeStd(connectedRegions, out ho_SelectedRegions, "max_area",
            70);

                HOperatorSet.AreaCenter(ho_SelectedRegions, out area, out row, out column);
                if (area == null) return false;
                if (area.I >= dparmas.NeighbourNoise) return false;
                else return true;
            }
            catch (Exception er)
            { return false; }
            finally
            {
            
                regionDifference.Dispose();
                imageReduced.Dispose();
                FastThresholdregion.Dispose();
                connectedRegions.Dispose();
                ho_SelectedRegions.Dispose();
            }
        }

        public void Dispose()
        {
          
        }

        /// 
        /// </summary>
        /// <param name = "obj" >  </ param >
        /// < returns ></ returns >
        public static bool ObjectValided(HObject obj)
        {
            try
            {
                if (obj == null)
                    return false;
                if (!obj.IsInitialized())
                {
                    return false;
                }
                if (obj.CountObj() < 1)
                {
                    return false;
                }
                return true;
            }
            catch (Exception ex)
            {
                return false;
            }

        }
    }
  
    public struct outputResultStruct
    {
        public outputResultStruct(bool flag)
        {
          //  hv_IsPositiveFaceList = new List<bool> ();
            runstatusFlag = flag;
            pixelrow = null;
            pixelcolumn = null;
            angle = null;
            machine_X = null;
            machine_Y = null;
            hv_Score1 = null;
            ho_ContoursAffinTransList = new List<HObject>();
            ho_CrossList = new List<HObject>();
            ho_RegionAffineTransList = new List<HObject>();
            ho_SelectedRegionsList = new List<HObject>();
        }
        //public List<bool> hv_IsPositiveFaceList;
        public bool runstatusFlag;
        public HTuple pixelrow;
        public HTuple pixelcolumn;
        public HTuple angle;
        public HTuple machine_X;
        public HTuple machine_Y;
        public HTuple hv_Score1;
        public List<HObject>  ho_ContoursAffinTransList;
        public List<HObject> ho_CrossList;
        public List<HObject> ho_RegionAffineTransList;
        public List<HObject> ho_SelectedRegionsList;
    }


    public enum eumSaveType
    {
        OK,
        NG,
        ALL,
        None

    }
    public enum eumImgDelWays
    {
        AutoClear,
        ManulClear

    }

    [Serializable]
    public class variableSetParmas
    {
        public variableSetParmas() {}

        //
        public HTuple matchNumber { get; set; } = 1;
        ////
       // public HTuple greedValue { get; set; } = 0.9;
        //
        public HTuple matchScore { get; set; } = 0.5;
        //
        public HTuple scaleDownLimit { get; set; } = 0.9;
        //
        public HTuple scaleUpLimit { get; set; } = 1.1;
        ////
        //public eumPolarity d_eumPolarity { get; set; }

        //   public HObject BlobRegion = null;

        //
        public HTuple MatchContrast { get; set; } = 30;
        //
        public HTuple StartAngle { get; set; } = -180;
        //
        public HTuple RangeAngle { get; set; } = 360;

        public HTuple Scale_range_min { get; set; } = 120;
        public HTuple Scale_range_max { get; set; } = 200;


        //
        public HTuple ThreshDownLimit { get; set; } = 50;
        //
        public HTuple ThreshUpLimit { get; set; } =255;

        //
        public HTuple SearchRatio { get; set; } = 1.1;

        //
        public HTuple NeighbourNoise { get; set; } = 100;

       
    }
    public enum eumPolarity
    {
        dark,
        light
    }

   
    [Serializable]
    public class producParma
    {
       
    
        public bool IsrobotXprotect = false;
        public bool IsrobotYprotect = false;
        public bool IsrobotRprotect = false;
        public double robotXprotectDown = 0;
        public double robotXprotectUp = 0;
        public double robotYprotectDown = 0;
        public double robotYprotectUp = 0;
        public double robotRprotectDown = 0;
        public double robotRprotectUp = 0;

    }
    //
    public struct ModelMatchStruct
    {


        //handle
        public HTuple hv_ModelID1;
        //
        public HTuple basepoint_Tuple;
        //
        // public HTuple ModelOrigin_Tuple;

        //public HObject modelregion;
    }

    [Serializable]
    public class SetModelROIData
    {
        public HTuple modelOrigionRow = 0;
        public HTuple modelOrigionColumn = 0;

        public HObject modelSearchROI = null;
    }
}
   


