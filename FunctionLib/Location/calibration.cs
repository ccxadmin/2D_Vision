//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//

using HalconDotNet;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace FunctionLib.Location
{
    public partial class HDevelopExport_calibr
    {
        public HDevelopExport_calibr()
        {

        }


        // Procedures 
        // External procedures 
        // Chapter: XLD / Creation
        // Short Description: Creates an arrow shaped XLD contour. 
        static void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
              HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = null, hv_ZeroLengthIndices = null;
            HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
            HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
            HTuple hv_ColP2 = null, hv_Index = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            try
            {
                //This procedure generates arrow shaped XLD contours,
                //pointing from (Row1, Column1) to (Row2, Column2).
                //If starting and end point are identical, a contour consisting
                //of a single point is returned.
                //
                //input parameteres:
                //Row1, Column1: Coordinates of the arrows' starting points
                //Row2, Column2: Coordinates of the arrows' end points
                //HeadLength, HeadWidth: Size of the arrow heads in pixels
                //
                //output parameter:
                //Arrow: The resulting XLD contour
                //
                //The input tuples Row1, Column1, Row2, and Column2 have to be of
                //the same length.
                //HeadLength and HeadWidth either have to be of the same length as
                //Row1, Column1, Row2, and Column2 or have to be a single element.
                //If one of the above restrictions is violated, an error will occur.
                //
                //
                //Init
                ho_Arrow.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Arrow);
                //
                //Calculate the arrow length
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
                //
                //Mark arrows with identical start and end point
                //(set Length to -1 to avoid division-by-zero exception)
                hv_ZeroLengthIndices = hv_Length.TupleFind(0);
                if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
                {
                    if (hv_Length == null)
                        hv_Length = new HTuple();
                    hv_Length[hv_ZeroLengthIndices] = -1;
                }
                //
                //Calculate auxiliary variables.
                hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
                hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
                hv_HalfHeadWidth = hv_HeadWidth / 2.0;
                //
                //Calculate end points of the arrow head.
                hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
                hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
                hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
                hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
                //
                //Finally create output XLD contour for each input point pair
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                    {
                        //Create_ single points for arrows with identical start and end point
                        ho_TempArrow.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                            hv_Index), hv_Column1.TupleSelect(hv_Index));
                    }
                    else
                    {
                        //Create arrow contour
                        ho_TempArrow.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                            hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                            hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                            hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                            ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                            hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                            hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                            hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                        ho_Arrow.Dispose();
                        ho_Arrow = ExpTmpOutVar_0;
                    }
                }
                ho_TempArrow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TempArrow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Text
        // Short Description: This procedure writes a text message. 
        static void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
            HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
            HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
            HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
            HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
            HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
            HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
            HTuple hv_FactorColumn = new HTuple(), hv_UseShadow = null;
            HTuple hv_ShadowColor = null, hv_Exception = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
            HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
            HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_CurrentColor = new HTuple();
            HTuple hv_Box_COPY_INP_TMP = hv_Box.Clone();
            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
            HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

            // Initialize local and output iconic variables 
            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Column: The column coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically
            //   for each new textline.
            //Box: If Box[0] is set to 'true', the text is written within an orange box.
            //     If set to' false', no box is displayed.
            //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
            //       the text is written in a box of that color.
            //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
            //       'true' -> display a shadow in a default color
            //       'false' -> display no shadow (same as if no second value is given)
            //       otherwise -> use given string as color string for the shadow color
            //
            //Prepare window
            HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
                out hv_Column2Part);
            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
                out hv_WidthWin, out hv_HeightWin);
            HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
            //
            //default settings
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
            {
                hv_Color_COPY_INP_TMP = "";
            }
            //
            hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
            //
            //Estimate extentions of text depending on font size.
            HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
            {
                hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                hv_C1 = hv_Column_COPY_INP_TMP.Clone();
            }
            else
            {
                //Transform image to window coordinates
                hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
            }
            //
            //Display text box depending on text size
            hv_UseShadow = 1;
            hv_ShadowColor = "gray";
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
            {
                if (hv_Box_COPY_INP_TMP == null)
                    hv_Box_COPY_INP_TMP = new HTuple();
                hv_Box_COPY_INP_TMP[0] = "#fce9d4";
                hv_ShadowColor = "#f28d26";
            }
            if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
                1))) != 0)
            {
                if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
                {
                    //Use default ShadowColor set above
                }
                else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
                    "false"))) != 0)
                {
                    hv_UseShadow = 0;
                }
                else
                {
                    hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
                    //Valid color?
                    try
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                            1));
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
                        throw new HalconException(hv_Exception);
                    }
                }
            }
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
            {
                //Valid color?
                try
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
                    throw new HalconException(hv_Exception);
                }
                //Calculate box extents
                hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                hv_Width = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                    hv_Width = hv_Width.TupleConcat(hv_W);
                }
                hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    ));
                hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                hv_R2 = hv_R1 + hv_FrameHeight;
                hv_C2 = hv_C1 + hv_FrameWidth;
                //Display rectangles
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                //Set shadow color
                HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
                if ((int)(hv_UseShadow) != 0)
                {
                    HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 1, hv_C1 + 1, hv_R2 + 1, hv_C2 + 1);
                }
                //Set box color
                HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
            }
            //Write text.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                    )));
                if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                    "auto")))) != 0)
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
                }
                else
                {
                    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                }
                hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
                HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index));
            }
            //Reset changed window settings
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                hv_Column2Part);

            return;
        }

        static void draw_rake(HTuple hv_WindowHandle, out HTuple hv_Row1, out HTuple hv_Column1,
            out HTuple hv_Row2, out HTuple hv_Column2)
        {



            // Local iconic variables 

            HObject ho_Regions;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            try
            {
                if (hv_WindowHandle.D > 100000)
                    HOperatorSet.SetFont(hv_WindowHandle, "Arial-" + "12");
                else
                    HOperatorSet.SetFont(hv_WindowHandle, "-Arial-" + "12" + "-*-*-*-*-1-");
                //提示
                disp_message(hv_WindowHandle, "点击鼠标左键画一条直线,点击右键确认", "image",
                    12, 12, "red", "false");
                //产生一个空显示对象，用于显示
                ho_Regions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Regions);
                //画矢量检测直线
                HOperatorSet.DrawLine(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_Row2,
                    out hv_Column2);
                //产生直线xld
                //gen_contour_polygon_xld (RegionLines, [Row1,Row2], [Column1,Column2])
                //存储到显示对象
                //concat_obj (Regions, RegionLines, Regions)
                //计算直线与x轴的夹角，逆时针方向为正向。
                //angle_lx (Row1, Column1, Row2, Column2, ATan)

                //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
                //ATan := ATan+rad(90)

                //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
                //for i := 1 to Elements by 1
                //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
                //if (Elements=1)
                //RowC := (Row1+Row2)*0.5
                //ColC := (Column1+Column2)*0.5
                //distance_pp (Row1, Column1, Row2, Column2, Distance)
                //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, Distance/2)
                //else
                //如果有多个测量矩形，产生该测量矩形xld
                //RowC := Row1+(((Row2-Row1)*(i-1))/(Elements-1))
                //ColC := Column1+(Column2-Column1)*(i-1)/(Elements-1)
                //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, DetectWidth/2)
                //endif
                //把测量矩形xld存储到显示对象
                //concat_obj (Regions, Rectangle, Regions)
                //if (i=1)
                //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                //RowL2 := RowC+DetectHeight/2*sin(-ATan)
                //RowL1 := RowC-DetectHeight/2*sin(-ATan)
                //ColL2 := ColC+DetectHeight/2*cos(-ATan)
                //ColL1 := ColC-DetectHeight/2*cos(-ATan)
                //gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, 5, 5)
                //把xld存储到显示对象
                //concat_obj (Regions, Arrow1, Regions)
                //endif
                //endfor

                ho_Regions.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();

                throw HDevExpDefaultException;
            }
        }

        static void pts_to_best_line(out HObject ho_Line, HTuple hv_Rows, HTuple hv_Cols,
            HTuple hv_ActiveNum, out HTuple hv_Row1, out HTuple hv_Column1, out HTuple hv_Row2,
            out HTuple hv_Column2)
        {



            // Local iconic variables 

            HObject ho_Contour = null;

            // Local control variables 

            HTuple hv_Length = null, hv_Nr = new HTuple();
            HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_Length1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            try
            {
                //初始化
                hv_Row1 = 0;
                hv_Column1 = 0;
                hv_Row2 = 0;
                hv_Column2 = 0;
                //产生一个空的直线对象，用于保存拟合后的直线
                ho_Line.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Line);
                //计算边缘数量
                HOperatorSet.TupleLength(hv_Cols, out hv_Length);
                //当边缘数量不小于有效点数时进行拟合
                if ((int)((new HTuple(hv_Length.TupleGreaterEqual(hv_ActiveNum))).TupleAnd(
                    new HTuple(hv_ActiveNum.TupleGreater(1)))) != 0)
                {
                    //halcon的拟合是基于xld的，需要把边缘连接成xld
                    ho_Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows, hv_Cols);
                    //拟合直线。使用的算法是'tukey'，其他算法请参考fit_line_contour_xld的描述部分。
                    HOperatorSet.FitLineContourXld(ho_Contour, "tukey", -1, 0, 5, 2, out hv_Row1,
                        out hv_Column1, out hv_Row2, out hv_Column2, out hv_Nr, out hv_Nc, out hv_Dist);
                    //判断拟合结果是否有效：如果拟合成功，数组中元素的数量大于0
                    HOperatorSet.TupleLength(hv_Dist, out hv_Length1);
                    if ((int)(new HTuple(hv_Length1.TupleLess(1))) != 0)
                    {
                        ho_Contour.Dispose();

                        return;
                    }
                    //根据拟合结果，产生直线xld
                    ho_Line.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Line, hv_Row1.TupleConcat(hv_Row2),
                        hv_Column1.TupleConcat(hv_Column2));
                }

                ho_Contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        static void rake(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
    HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold,
    HTuple hv_Transition, HTuple hv_Select, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2,
    HTuple hv_Column2, out HTuple hv_ResultRow, out HTuple hv_ResultColumn)
        {
            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Cross = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
            HTuple hv_i = null, hv_RowC = new HTuple(), hv_ColC = new HTuple();
            HTuple hv_Distance = new HTuple(), hv_MsrHandle_Measure = new HTuple();
            HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
            HTuple hv_Amplitude = new HTuple(), hv_tRow = new HTuple();
            HTuple hv_tCol = new HTuple(), hv_t = new HTuple(), hv_Number = new HTuple();
            HTuple hv_j = new HTuple();
            HTuple hv_DetectWidth_COPY_INP_TMP = hv_DetectWidth.Clone();
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //初始化边缘坐标数组
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();
            //产生直线xld
            ho_RegionLines.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_Row1.TupleConcat(hv_Row2),
                hv_Column1.TupleConcat(hv_Column2));
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            HOperatorSet.AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_ATan);

            //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
            hv_ATan = hv_ATan + ((new HTuple(90)).TupleRad());

            //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
            HTuple end_val18 = hv_Elements;
            HTuple step_val18 = 1;
            for (hv_i = 1; hv_i.Continue(end_val18, step_val18); hv_i = hv_i.TupleAdd(step_val18))
            {
                //RowC := Row1+(((Row2-Row1)*i)/(Elements+1))
                //ColC := Column1+(Column2-Column1)*i/(Elements+1)
                //if (RowC>Height-1 or RowC<0 or ColC>Width-1 or ColC<0)
                //continue
                //endif
                //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
                if ((int)(new HTuple(hv_Elements.TupleEqual(1))) != 0)
                {
                    hv_RowC = (hv_Row1 + hv_Row2) * 0.5;
                    hv_ColC = (hv_Column1 + hv_Column2) * 0.5;
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Distance);
                    hv_DetectWidth_COPY_INP_TMP = hv_Distance.Clone();
                    //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, Distance/2)
                }
                else
                {
                    //如果有多个测量矩形，产生该测量矩形xld
                    hv_RowC = hv_Row1 + (((hv_Row2 - hv_Row1) * (hv_i - 1)) / (hv_Elements - 1));
                    hv_ColC = hv_Column1 + (((hv_Column2 - hv_Column1) * (hv_i - 1)) / (hv_Elements - 1));
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, DetectWidth/2)
                }

                //把测量矩形xld存储到显示对象
                //*     concat_obj (Regions, Rectangle, Regions)
                //if (i=1)
                //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                //RowL2 := RowC+DetectHeight/2*sin(-ATan)
                //RowL1 := RowC-DetectHeight/2*sin(-ATan)
                //ColL2 := ColC+DetectHeight/2*cos(-ATan)
                //ColL1 := ColC-DetectHeight/2*cos(-ATan)
                //*         gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, 15, 15)
                //把xld存储到显示对象
                //*         concat_obj (Regions, Arrow1, Regions)
                //endif


                //产生测量对象句柄
                HOperatorSet.GenMeasureRectangle2(hv_RowC, hv_ColC, hv_ATan, hv_DetectHeight / 2,
                    hv_DetectWidth_COPY_INP_TMP / 2, hv_Width, hv_Height, "nearest_neighbor",
                    out hv_MsrHandle_Measure);

                //设置极性
                if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
                {
                    hv_Transition_COPY_INP_TMP = "negative";
                }
                else
                {
                    if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                    {

                        hv_Transition_COPY_INP_TMP = "positive";
                    }
                    else
                    {
                        hv_Transition_COPY_INP_TMP = "all";
                    }
                }
                //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
                if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
                {
                    hv_Select_COPY_INP_TMP = "first";
                }
                else
                {
                    if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                    {

                        hv_Select_COPY_INP_TMP = "last";
                    }
                    else
                    {
                        hv_Select_COPY_INP_TMP = "all";
                    }
                }
                //检测边缘
                HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                    hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                    out hv_Amplitude, out hv_Distance);
                //清除测量对象句柄
                HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);

                //临时变量初始化
                //tRow，tCol保存找到指定边缘的坐标
                hv_tRow = 0;
                hv_tCol = 0;
                //t保存边缘的幅度绝对值
                hv_t = 0;
                //找到的边缘必须至少为1个
                HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
                if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
                {
                    continue;
                }
                //有多个边缘时，选择幅度绝对值最大的边缘
                HTuple end_val102 = hv_Number - 1;
                HTuple step_val102 = 1;
                for (hv_j = 0; hv_j.Continue(end_val102, step_val102); hv_j = hv_j.TupleAdd(step_val102))
                {
                    if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                        hv_t))) != 0)
                    {

                        hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                        hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                        hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                    }
                }
                //把找到的边缘保存在输出数组
                if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
                {
                    hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                    hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
                }
            }
            if ((int)(new HTuple((new HTuple(hv_ResultRow.TupleLength())).TupleGreater(0))) != 0)
            {
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
                    4, 0.785398);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Cross, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
            }
            ho_RegionLines.Dispose();
            ho_Cross.Dispose();

            return;
        }



        static void rake2(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
            HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold,
            HTuple hv_Transition, HTuple hv_Select, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2,
            HTuple hv_Column2, out HTuple hv_ResultRow, out HTuple hv_ResultColumn)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Rectangle = null;
            HObject ho_Arrow1 = null, ho_Cross = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
            HTuple hv_i = null, hv_RowC = new HTuple(), hv_ColC = new HTuple();
            HTuple hv_Distance = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
            HTuple hv_ColL1 = new HTuple(), hv_MsrHandle_Measure = new HTuple();
            HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
            HTuple hv_Amplitude = new HTuple(), hv_tRow = new HTuple();
            HTuple hv_tCol = new HTuple(), hv_t = new HTuple(), hv_Number = new HTuple();
            HTuple hv_j = new HTuple();
            HTuple hv_DetectWidth_COPY_INP_TMP = hv_DetectWidth.Clone();
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            try
            {
                //获取图像尺寸
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                //产生一个空显示对象，用于显示
                ho_Regions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Regions);
                //初始化边缘坐标数组
                hv_ResultRow = new HTuple();
                hv_ResultColumn = new HTuple();
                //产生直线xld
                ho_RegionLines.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_Row1.TupleConcat(hv_Row2),
                    hv_Column1.TupleConcat(hv_Column2));
                //存储到显示对象
                //concat_obj (Regions, RegionLines, Regions)
                //计算直线与x轴的夹角，逆时针方向为正向。
                HOperatorSet.AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_ATan);

                //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
                hv_ATan = hv_ATan + ((new HTuple(90)).TupleRad());

                //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
                HTuple end_val18 = hv_Elements;
                HTuple step_val18 = 1;
                for (hv_i = 1; hv_i.Continue(end_val18, step_val18); hv_i = hv_i.TupleAdd(step_val18))
                {
                    //RowC := Row1+(((Row2-Row1)*i)/(Elements+1))
                    //ColC := Column1+(Column2-Column1)*i/(Elements+1)
                    //if (RowC>Height-1 or RowC<0 or ColC>Width-1 or ColC<0)
                    //continue
                    //endif
                    //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
                    if ((int)(new HTuple(hv_Elements.TupleEqual(1))) != 0)
                    {
                        hv_RowC = (hv_Row1 + hv_Row2) * 0.5;
                        hv_ColC = (hv_Column1 + hv_Column2) * 0.5;
                        //判断是否超出图像,超出不检测边缘
                        if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                            new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                            hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                        {
                            continue;
                        }
                        HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Distance);
                        hv_DetectWidth_COPY_INP_TMP = hv_Distance.Clone();
                        ho_Rectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                            hv_ATan, hv_DetectHeight / 2, hv_Distance / 2);
                    }
                    else
                    {
                        //如果有多个测量矩形，产生该测量矩形xld
                        hv_RowC = hv_Row1 + (((hv_Row2 - hv_Row1) * (hv_i - 1)) / (hv_Elements - 1));
                        hv_ColC = hv_Column1 + (((hv_Column2 - hv_Column1) * (hv_i - 1)) / (hv_Elements - 1));
                        //判断是否超出图像,超出不检测边缘
                        if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                            new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                            hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                        {
                            continue;
                        }
                        ho_Rectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                            hv_ATan, hv_DetectHeight / 2, hv_DetectWidth_COPY_INP_TMP / 2);
                    }

                    //把测量矩形xld存储到显示对象
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                    if ((int)(new HTuple(hv_i.TupleEqual(1))) != 0)
                    {
                        //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                        hv_RowL2 = hv_RowC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                        hv_RowL1 = hv_RowC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                        hv_ColL2 = hv_ColC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                        hv_ColL1 = hv_ColC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                        ho_Arrow1.Dispose();
                        gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                            15, 15);
                        //把xld存储到显示对象
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                            ho_Regions.Dispose();
                            ho_Regions = ExpTmpOutVar_0;
                        }
                    }
                    //产生测量对象句柄
                    HOperatorSet.GenMeasureRectangle2(hv_RowC, hv_ColC, hv_ATan, hv_DetectHeight / 2,
                        hv_DetectWidth_COPY_INP_TMP / 2, hv_Width, hv_Height, "nearest_neighbor",
                        out hv_MsrHandle_Measure);

                    //设置极性
                    if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
                    {
                        hv_Transition_COPY_INP_TMP = "negative";
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                        {

                            hv_Transition_COPY_INP_TMP = "positive";
                        }
                        else
                        {
                            hv_Transition_COPY_INP_TMP = "all";
                        }
                    }
                    //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
                    if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
                    {
                        hv_Select_COPY_INP_TMP = "first";
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                        {

                            hv_Select_COPY_INP_TMP = "last";
                        }
                        else
                        {
                            hv_Select_COPY_INP_TMP = "all";
                        }
                    }
                    //检测边缘
                    HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                        hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                        out hv_Amplitude, out hv_Distance);
                    //清除测量对象句柄
                    HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);

                    //临时变量初始化
                    //tRow，tCol保存找到指定边缘的坐标
                    hv_tRow = 0;
                    hv_tCol = 0;
                    //t保存边缘的幅度绝对值
                    hv_t = 0;
                    //找到的边缘必须至少为1个
                    HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
                    if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
                    {
                        continue;
                    }
                    //有多个边缘时，选择幅度绝对值最大的边缘
                    HTuple end_val100 = hv_Number - 1;
                    HTuple step_val100 = 1;
                    for (hv_j = 0; hv_j.Continue(end_val100, step_val100); hv_j = hv_j.TupleAdd(step_val100))
                    {
                        if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                            hv_t))) != 0)
                        {

                            hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                            hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                            hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                        }
                    }
                    //把找到的边缘保存在输出数组
                    if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
                    {
                        hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                        hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_ResultRow.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
                        4, 0.785398);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Cross, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }
                ho_RegionLines.Dispose();
                ho_Rectangle.Dispose();
                ho_Arrow1.Dispose();
                ho_Cross.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_RegionLines.Dispose();
                ho_Rectangle.Dispose();
                ho_Arrow1.Dispose();
                ho_Cross.Dispose();

                throw HDevExpDefaultException;
            }
        }

        static void draw_spoke(HObject ho_Image, HTuple hv_WindowHandle, out HTuple hv_ROIRows,
     out HTuple hv_ROICols, out HTuple hv_Direct)
        {


            // Local iconic variables 

            HObject ho_Regions, ho_ContOut1, ho_Contour;

            // Local control variables 

            HTuple hv_Rows = null, hv_Cols = null, hv_Weights = null;
            HTuple hv_Length1 = null, hv_RowC = null, hv_ColumnC = null;
            HTuple hv_Radius = null, hv_StartPhi = null, hv_EndPhi = null;
            HTuple hv_PointOrder = null, hv_Row1 = null, hv_Column1 = null;
            HTuple hv_Row2 = null, hv_Column2 = null, hv_DistanceStart = null;
            HTuple hv_DistanceEnd = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_ContOut1);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            hv_ROIRows = new HTuple();
            hv_ROICols = new HTuple();
            hv_Direct = new HTuple();
            //提示
            if (hv_WindowHandle.D > 100000)
                HOperatorSet.SetFont(hv_WindowHandle, "Arialw-" + "12");
            else
                HOperatorSet.SetFont(hv_WindowHandle, "-Arial-" + "12" + "-*-*-*-*-1-");

            disp_message(hv_WindowHandle, new HTuple("1、画4个以上点确定一个圆弧,点击右键确认"),
                "image", 12, 12, "red", "false");
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //沿着圆弧或圆的边缘画点
            ho_ContOut1.Dispose();
            HOperatorSet.DrawNurbs(out ho_ContOut1, hv_WindowHandle, "true", "true", "true",
                "true", 3, out hv_Rows, out hv_Cols, out hv_Weights);
            //至少要4个点
            HOperatorSet.TupleLength(hv_Weights, out hv_Length1);
            if ((int)(new HTuple(hv_Length1.TupleLess(4))) != 0)
            {
                if (hv_WindowHandle.D > 100000)
                    HOperatorSet.SetFont(hv_WindowHandle, "Arial-" + "12");
                else
                    HOperatorSet.SetFont(hv_WindowHandle, "-Arial-" + "12" + "-*-*-*-*-1-");
                disp_message(hv_WindowHandle, "提示：点数太少，请重画", "window", 32, 12, "red",
                    "false");
                hv_ROIRows = new HTuple();
                hv_ROICols = new HTuple();
                ho_Regions.Dispose();
                ho_ContOut1.Dispose();
                ho_Contour.Dispose();

                return;
            }
            //获取点
            hv_ROIRows = hv_Rows.Clone();
            hv_ROICols = hv_Cols.Clone();
            //产生xld
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
            //用回归线法（不抛出异常点，所有点权重一样）拟合圆
            HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, out hv_RowC,
                out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
            //根据拟合结果产生xld，并保持到显示对象
            //gen_circle_contour_xld (ContCircle, RowC, ColumnC, Radius, StartPhi, EndPhi, PointOrder, 3)
            //concat_obj (Regions, ContCircle, Regions)

            //获取圆或圆弧xld上的点坐标
            //get_contour_xld (ContCircle, RowXLD, ColXLD)
            //显示图像和圆弧
            //if (HDevWindowStack.IsOpen())
            //{
            //    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            //}
            //if (HDevWindowStack.IsOpen())
            //{
            //    HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
            //}
            //if (HDevWindowStack.IsOpen())
            //{
            //    //dev_display (ContCircle)
            //}
            //产生并显示圆心
            //gen_cross_contour_xld (Cross, RowC, ColumnC, 60, 0.785398)
            //if (HDevWindowStack.IsOpen())
            //{
            //    //dev_display (Cross)
            //}

            HOperatorSet.ClearWindow(hv_WindowHandle);
            HOperatorSet.DispObj(ho_Image, hv_WindowHandle);
            if (hv_WindowHandle.D > 100000)
                HOperatorSet.SetFont(hv_WindowHandle, "Arial-" + "12");
            else
                HOperatorSet.SetFont(hv_WindowHandle, "-Arial-" + "12" + "-*-*-*-*-1-");
            //提示
            disp_message(hv_WindowHandle, "2、远离圆心，画箭头确定边缘检测方向，点击右键确认",
                "window", 12, 12, "red", "false");
            //画线，确定检测方向
            HOperatorSet.DrawLine(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_Row2,
                out hv_Column2);
            //求圆心到检测方向直线起点的距离
            HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row1, hv_Column1, out hv_DistanceStart);
            //求圆心到检测方向直线终点的距离
            HOperatorSet.DistancePp(hv_RowC, hv_ColumnC, hv_Row2, hv_Column2, out hv_DistanceEnd);
            if ((int)(new HTuple(hv_DistanceStart.TupleGreater(hv_DistanceEnd))) != 0)
            {
                //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                hv_Direct = "inner";
            }
            else
            {
                //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                hv_Direct = "outer";
            }
            //求圆或圆弧xld上的点的数量
            //tuple_length (ColXLD, Length2)
            //判断检测的边缘数量是否过少
            //if (Elements<3)
            //ROIRows := []
            //ROICols := []
            //disp_message (WindowHandle, '检测的边缘数量太少，请重新设置!', 'window', 52, 12, 'red', 'false')
            //return ()
            //endif
            //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
            //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
            //for i := 0 to Elements-1 by 1

            //if (RowXLD[0]=RowXLD[Length2-1])
            //xld的起点和终点坐标相对，为圆
            //tuple_int (1.0*Length2/(Elements)*(i), j)

            //else
            //否则为圆弧
            //tuple_int (1.0*Length2/(Elements-1)*(i), j)
            //endif
            //索引越界，强制赋值为最后一个索引
            //if (j>=Length2)
            //j := Length2-1
            //continue
            //endif
            //获取卡尺工具中心
            //RowE := RowXLD[j]
            //ColE := ColXLD[j]

            //如果圆心到检测方向直线的起点的距离大于圆心到检测方向直线的终点的距离，搜索方向由圆外指向圆心
            //如果圆心到检测方向直线的起点的距离不大于圆心到检测方向直线的终点的距离，搜索方向由圆心指向圆外
            //if (DistanceStart>DistanceEnd)
            //求卡尺工具的边缘搜索方向
            //求圆心指向边缘的矢量的角度
            //tuple_atan2 (-RowE+RowC, ColE-ColumnC, ATan)
            //角度反向
            //ATan := rad(180)+ATan
            //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
            //Direct := 'inner'
            //else
            //求卡尺工具的边缘搜索方向
            //求圆心指向边缘的矢量的角度
            //tuple_atan2 (-RowE+RowC, ColE-ColumnC, ATan)
            //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
            //Direct := 'outer'
            //endif

            //产生卡尺xld，并保持到显示对象
            //gen_rectangle2_contour_xld (Rectangle1, RowE, ColE, ATan, DetectHeight/2, DetectWidth/2)
            //concat_obj (Regions, Rectangle1, Regions)

            //用箭头xld指示边缘搜索方向，并保持到显示对象
            //if (i=0)
            //RowL2 := RowE+DetectHeight/2*sin(-ATan)
            //RowL1 := RowE-DetectHeight/2*sin(-ATan)
            //ColL2 := ColE+DetectHeight/2*cos(-ATan)
            //ColL1 := ColE-DetectHeight/2*cos(-ATan)
            //gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, DetectHeight, 5)
            //concat_obj (Regions, Arrow1, Regions)
            //endif
            //endfor

            ho_Regions.Dispose();
            ho_ContOut1.Dispose();
            ho_Contour.Dispose();

            return;
        }

        static void pts_to_best_circle(out HObject ho_Circle, HTuple hv_Rows, HTuple hv_Cols,
            HTuple hv_ArcType, HTuple hv_ActiveNum, out HTuple hv_RowCenter, out HTuple hv_ColCenter,
            out HTuple hv_Radius, out HTuple hv_StartPhi, out HTuple hv_EndPhi, out HTuple hv_PointOrder,
            out HTuple hv_ArcAngle)
        {



            // Local iconic variables 

            HObject ho_Contour = null, ho_Circle1 = null, ho_Circle2 = null;

            // Local control variables 

            HTuple hv_Length = null, hv_Length1 = new HTuple();
            HTuple hv_DistanceMin1 = new HTuple(), hv_DistanceMax1 = new HTuple();
            HTuple hv_DistanceMin2 = new HTuple(), hv_DistanceMax2 = new HTuple();
            HTuple hv_Sum1 = new HTuple(), hv_Sum2 = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_CircleLength = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Circle1);
            HOperatorSet.GenEmptyObj(out ho_Circle2);
            hv_StartPhi = new HTuple();
            hv_EndPhi = new HTuple();
            hv_PointOrder = new HTuple();
            hv_ArcAngle = new HTuple();
            //初始化
            hv_RowCenter = 0;
            hv_ColCenter = 0;
            hv_Radius = 0;
            //_Rows := []
            //_Cols := []
            //产生一个空的直线对象，用于保存拟合后的圆
            ho_Circle.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Circle);
            //计算边缘数量
            HOperatorSet.TupleLength(hv_Cols, out hv_Length);
            //当边缘数量不小于有效点数时进行拟合
            if ((int)((new HTuple(hv_Length.TupleGreaterEqual(hv_ActiveNum))).TupleAnd(new HTuple(hv_ActiveNum.TupleGreater(
                2)))) != 0)
            {
                //halcon的拟合是基于xld的，需要把边缘连接成xld
                if ((int)(new HTuple(hv_ArcType.TupleEqual("circle"))) != 0)
                {
                    //如果是闭合的圆，轮廓需要首尾相连
                    //_Rows := [_Rows,Rows,Rows[0]]
                    //_Cols := [_Cols,Cols,Cols[0]]
                    ho_Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows.TupleConcat(hv_Rows.TupleSelect(
                        0)), hv_Cols.TupleConcat(hv_Cols.TupleSelect(0)));
                    //gen_contour_polygon_xld (Contour, Rows, Cols)
                }
                else
                {
                    ho_Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows, hv_Cols);
                }
                //拟合圆。使用的算法是''geotukey''，其他算法请参考fit_circle_contour_xld的描述部分。
                HOperatorSet.FitCircleContourXld(ho_Contour, "geotukey", -1, 0, 0, 3, 2, out hv_RowCenter,
                    out hv_ColCenter, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
                //判断拟合结果是否有效：如果拟合成功，数组中元素的数量大于0
                HOperatorSet.TupleLength(hv_StartPhi, out hv_Length1);
                if ((int)(new HTuple(hv_Length1.TupleLess(1))) != 0)
                {
                    ho_Contour.Dispose();
                    ho_Circle1.Dispose();
                    ho_Circle2.Dispose();

                    return;
                }
                //根据拟合结果，产生直线xld
                if ((int)(new HTuple(hv_ArcType.TupleEqual("arc"))) != 0)
                {
                    //判断圆弧的方向：顺时针还是逆时针
                    //halcon求圆弧会出现方向混乱的问题
                    ho_Circle1.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle1, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, "positive", 1);
                    ho_Circle2.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle2, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, "negative", 1);

                    HOperatorSet.DistancePc(ho_Circle1, hv_Rows, hv_Cols, out hv_DistanceMin1,
                        out hv_DistanceMax1);
                    HOperatorSet.DistancePc(ho_Circle2, hv_Rows, hv_Cols, out hv_DistanceMin2,
                        out hv_DistanceMax2);
                    HOperatorSet.TupleSum(hv_DistanceMin1, out hv_Sum1);
                    HOperatorSet.TupleSum(hv_DistanceMin2, out hv_Sum2);
                    if ((int)(new HTuple(hv_Sum1.TupleLess(hv_Sum2))) != 0)
                    {
                        hv_PointOrder = "positive";
                    }
                    else
                    {
                        hv_PointOrder = "negative";
                    }
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);
                    HOperatorSet.GetContourXld(ho_Circle, out hv_Row, out hv_Col);
                    HOperatorSet.AngleLl(hv_RowCenter, hv_ColCenter, hv_Row.TupleSelect(0), hv_Col.TupleSelect(
                        0), hv_RowCenter, hv_ColCenter, hv_Row.TupleSelect((new HTuple(hv_Row.TupleLength()
                        )) - 1), hv_Col.TupleSelect((new HTuple(hv_Row.TupleLength())) - 1), out hv_ArcAngle);
                    if ((int)(0) != 0)
                    {
                        HOperatorSet.LengthXld(ho_Circle, out hv_CircleLength);
                        hv_ArcAngle = hv_EndPhi - hv_StartPhi;
                        if ((int)(new HTuple(hv_CircleLength.TupleGreater(((new HTuple(180)).TupleRad()
                            ) * hv_Radius))) != 0)
                        {
                            if ((int)(new HTuple(((hv_ArcAngle.TupleAbs())).TupleLess((new HTuple(180)).TupleRad()
                                ))) != 0)
                            {
                                if ((int)(new HTuple(hv_ArcAngle.TupleGreater(0))) != 0)
                                {
                                    hv_ArcAngle = ((new HTuple(360)).TupleRad()) - hv_ArcAngle;
                                }
                                else
                                {
                                    hv_ArcAngle = ((new HTuple(360)).TupleRad()) + hv_ArcAngle;
                                }
                            }
                        }
                        else
                        {
                            if ((int)(new HTuple(hv_CircleLength.TupleLess(((new HTuple(180)).TupleRad()
                                ) * hv_Radius))) != 0)
                            {
                                if ((int)(new HTuple(((hv_ArcAngle.TupleAbs())).TupleGreater((new HTuple(180)).TupleRad()
                                    ))) != 0)
                                {
                                    if ((int)(new HTuple(hv_ArcAngle.TupleGreater(0))) != 0)
                                    {
                                        hv_ArcAngle = hv_ArcAngle - ((new HTuple(360)).TupleRad());
                                    }
                                    else
                                    {
                                        hv_ArcAngle = ((new HTuple(360)).TupleRad()) + hv_ArcAngle;
                                    }
                                }
                            }

                        }
                    }
                }
                else
                {
                    hv_StartPhi = 0;
                    hv_EndPhi = (new HTuple(360)).TupleRad();
                    hv_ArcAngle = (new HTuple(360)).TupleRad();
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_Circle, hv_RowCenter, hv_ColCenter,
                        hv_Radius, hv_StartPhi, hv_EndPhi, hv_PointOrder, 1);
                }
            }

            ho_Contour.Dispose();
            ho_Circle1.Dispose();
            ho_Circle2.Dispose();

            return;
        }

        static void spoke(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
            HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold,
            HTuple hv_Transition, HTuple hv_Select, HTuple hv_ROIRows, HTuple hv_ROICols,
            HTuple hv_Direct, out HTuple hv_ResultRow, out HTuple hv_ResultColumn, out HTuple hv_ArcType)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Contour, ho_ContCircle, ho_Rectangle1 = null;
            HObject ho_Arrow1 = null, ho_Cross = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_RowC = null;
            HTuple hv_ColumnC = null, hv_Radius = null, hv_StartPhi = null;
            HTuple hv_EndPhi = null, hv_PointOrder = null, hv_RowXLD = null;
            HTuple hv_ColXLD = null, hv_Length2 = null, hv_i = null;
            HTuple hv_j = new HTuple(), hv_RowE = new HTuple(), hv_ColE = new HTuple();
            HTuple hv_ATan = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
            HTuple hv_ColL1 = new HTuple(), hv_MsrHandle_Measure = new HTuple();
            HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
            HTuple hv_Amplitude = new HTuple(), hv_Distance = new HTuple();
            HTuple hv_tRow = new HTuple(), hv_tCol = new HTuple();
            HTuple hv_t = new HTuple(), hv_Number = new HTuple(), hv_k = new HTuple();
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_ContCircle);
            HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            hv_ArcType = new HTuple();
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //初始化边缘坐标数组
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();

            //产生xld
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
            //用回归线法（不抛出异常点，所有点权重一样）拟合圆
            HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, out hv_RowC,
                out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
            //根据拟合结果产生xld，并保持到显示对象
            ho_ContCircle.Dispose();
            HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius,
                hv_StartPhi, hv_EndPhi, hv_PointOrder, 3);
            //concat_obj (Regions, ContCircle, Regions)

            //获取圆或圆弧xld上的点坐标
            HOperatorSet.GetContourXld(ho_ContCircle, out hv_RowXLD, out hv_ColXLD);

            //求圆或圆弧xld上的点的数量
            HOperatorSet.TupleLength(hv_ColXLD, out hv_Length2);
            if ((int)(new HTuple(hv_Elements.TupleLess(3))) != 0)
            {
              
                HOperatorSet.SetFont(3600, "-Arial-" + "12" + "-*-*-*-*-1-");
                disp_message(3600, "检测的边缘数量太少，请重新设置!", "window", 52, 12, "red",
                    "false");
                ho_Contour.Dispose();
                ho_ContCircle.Dispose();
                ho_Rectangle1.Dispose();
                ho_Arrow1.Dispose();
                ho_Cross.Dispose();

                return;
            }
            //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
            //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
            HTuple end_val27 = hv_Elements - 1;
            HTuple step_val27 = 1;
            for (hv_i = 0; hv_i.Continue(end_val27, step_val27); hv_i = hv_i.TupleAdd(step_val27))
            {

                if ((int)(new HTuple(((hv_RowXLD.TupleSelect(0))).TupleEqual(hv_RowXLD.TupleSelect(
                    hv_Length2 - 1)))) != 0)
                {
                    //xld的起点和终点坐标相对，为圆
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / hv_Elements) * hv_i, out hv_j);
                    hv_ArcType = "circle";
                }
                else
                {
                    //否则为圆弧
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / (hv_Elements - 1)) * hv_i, out hv_j);
                    hv_ArcType = "arc";
                }
                //索引越界，强制赋值为最后一个索引
                if ((int)(new HTuple(hv_j.TupleGreaterEqual(hv_Length2))) != 0)
                {
                    hv_j = hv_Length2 - 1;
                    //continue
                }
                //获取卡尺工具中心
                hv_RowE = hv_RowXLD.TupleSelect(hv_j);
                hv_ColE = hv_ColXLD.TupleSelect(hv_j);

                //超出图像区域，不检测，否则容易报异常
                if ((int)((new HTuple((new HTuple((new HTuple(hv_RowE.TupleGreater(hv_Height - 1))).TupleOr(
                    new HTuple(hv_RowE.TupleLess(0))))).TupleOr(new HTuple(hv_ColE.TupleGreater(
                    hv_Width - 1))))).TupleOr(new HTuple(hv_ColE.TupleLess(0)))) != 0)
                {
                    continue;
                }
                //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                if ((int)(new HTuple(hv_Direct.TupleEqual("inner"))) != 0)
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                    //角度反向
                    hv_ATan = ((new HTuple(180)).TupleRad()) + hv_ATan;
                }
                else
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                }


                //产生卡尺xld，并保持到显示对象
                ho_Rectangle1.Dispose();
                HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan,
                    hv_DetectHeight / 2, hv_DetectWidth / 2);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle1, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
                //用箭头xld指示边缘搜索方向，并保持到显示对象
                if ((int)(new HTuple(hv_i.TupleEqual(0))) != 0)
                {
                    hv_RowL2 = hv_RowE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_RowL1 = hv_RowE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_ColL2 = hv_ColE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    hv_ColL1 = hv_ColE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    ho_Arrow1.Dispose();
                    gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                        5, 5);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }


                //产生测量对象句柄
                HOperatorSet.GenMeasureRectangle2(hv_RowE, hv_ColE, hv_ATan, hv_DetectHeight / 2,
                    hv_DetectWidth / 2, hv_Width, hv_Height, "nearest_neighbor", out hv_MsrHandle_Measure);

                //设置极性
                if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
                {
                    hv_Transition_COPY_INP_TMP = "negative";
                }
                else
                {
                    if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                    {

                        hv_Transition_COPY_INP_TMP = "positive";
                    }
                    else
                    {
                        hv_Transition_COPY_INP_TMP = "all";
                    }
                }
                //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
                if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
                {
                    hv_Select_COPY_INP_TMP = "first";
                }
                else
                {
                    if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                    {

                        hv_Select_COPY_INP_TMP = "last";
                    }
                    else
                    {
                        hv_Select_COPY_INP_TMP = "all";
                    }
                }
                //检测边缘
                HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                    hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                    out hv_Amplitude, out hv_Distance);


                //清除测量对象句柄
                HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);
                //临时变量初始化
                //tRow，tCol保存找到指定边缘的坐标
                hv_tRow = 0;
                hv_tCol = 0;
                //t保存边缘的幅度绝对值
                hv_t = 0;
                HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
                //找到的边缘必须至少为1个
                if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
                {
                    continue;
                }
                //有多个边缘时，选择幅度绝对值最大的边缘
                HTuple end_val122 = hv_Number - 1;
                HTuple step_val122 = 1;
                for (hv_k = 0; hv_k.Continue(end_val122, step_val122); hv_k = hv_k.TupleAdd(step_val122))
                {
                    if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_k))).TupleAbs())).TupleGreater(
                        hv_t))) != 0)
                    {

                        hv_tRow = hv_RowEdge.TupleSelect(hv_k);
                        hv_tCol = hv_ColEdge.TupleSelect(hv_k);
                        hv_t = ((hv_Amplitude.TupleSelect(hv_k))).TupleAbs();
                    }
                }
                //把找到的边缘保存在输出数组
                if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
                {

                    hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                    hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
                }
            }
            if ((int)(new HTuple((new HTuple(hv_ResultRow.TupleLength())).TupleGreater(0))) != 0)
            {
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
                    4, 0.785398);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Cross, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }

            }
            ho_Contour.Dispose();
            ho_ContCircle.Dispose();
            ho_Rectangle1.Dispose();
            ho_Arrow1.Dispose();
            ho_Cross.Dispose();

            return;
        }

       public   static void get_spoke_region(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
    HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Direct,
     EumTestModule eumTestModule = EumTestModule.create, HObject searchROI = null, HTuple _ROIRows = null, HTuple _ROICols = null
              )
        {

            HTuple hv_ROIRows, hv_ROICols;
            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Contour, ho_ContCircle, ho_Rectangle1 = null;
            HObject ho_Arrow1 = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_RowC = null;
            HTuple hv_ColumnC = null, hv_Radius = null, hv_StartPhi = null;
            HTuple hv_EndPhi = null, hv_PointOrder = null, hv_RowXLD = null;
            HTuple hv_ColXLD = null, hv_Length2 = null, hv_i = null;
            HTuple hv_j = new HTuple(), hv_ArcType = new HTuple();
            HTuple hv_RowE = new HTuple(), hv_ColE = new HTuple();
            HTuple hv_ATan = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
            HTuple hv_ColL1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_ContCircle);
            HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);

            if (eumTestModule == EumTestModule.create)
            {
                if (_ROIRows == null || _ROICols == null)
                {
                    ho_Regions = null;
                    return;
                }

                hv_ROIRows = _ROIRows;
                hv_ROICols = _ROICols;
            
            }
            else
                HOperatorSet.GetContourXld(searchROI, out hv_ROIRows, out hv_ROICols);

            //产生xld
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_ROIRows, hv_ROICols);
            //用回归线法（不抛出异常点，所有点权重一样）拟合圆
            HOperatorSet.FitCircleContourXld(ho_Contour, "algebraic", -1, 0, 0, 1, 2, out hv_RowC,
                out hv_ColumnC, out hv_Radius, out hv_StartPhi, out hv_EndPhi, out hv_PointOrder);
            //根据拟合结果产生xld，并保持到显示对象
            ho_ContCircle.Dispose();
            HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_RowC, hv_ColumnC, hv_Radius,
                hv_StartPhi, hv_EndPhi, hv_PointOrder, 3);
            //concat_obj (Regions, ContCircle, Regions)

            //获取圆或圆弧xld上的点坐标
            HOperatorSet.GetContourXld(ho_ContCircle, out hv_RowXLD, out hv_ColXLD);

            //求圆或圆弧xld上的点的数量
            HOperatorSet.TupleLength(hv_ColXLD, out hv_Length2);
            if ((int)(new HTuple(hv_Elements.TupleLess(3))) != 0)
            {
              
                HOperatorSet.SetFont(3600, "-Arial-" + "12" + "-*-*-*-*-1-");
                disp_message(3600, "检测的边缘数量太少，请重新设置!", "window", 52, 12, "red",
                    "false");
                ho_Contour.Dispose();
                ho_ContCircle.Dispose();
                ho_Rectangle1.Dispose();
                ho_Arrow1.Dispose();

                return;
            }
            //如果xld是圆弧，有Length2个点，从起点开始，等间距（间距为Length2/(Elements-1)）取Elements个点，作为卡尺工具的中点
            //如果xld是圆，有Length2个点，以0°为起点，从起点开始，等间距（间距为Length2/(Elements)）取Elements个点，作为卡尺工具的中点
            HTuple end_val24 = hv_Elements - 1;
            HTuple step_val24 = 1;
            for (hv_i = 0; hv_i.Continue(end_val24, step_val24); hv_i = hv_i.TupleAdd(step_val24))
            {

                if ((int)(new HTuple(((hv_RowXLD.TupleSelect(0))).TupleEqual(hv_RowXLD.TupleSelect(
                    hv_Length2 - 1)))) != 0)
                {
                    //xld的起点和终点坐标相对，为圆
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / hv_Elements) * hv_i, out hv_j);
                    hv_ArcType = "circle";
                }
                else
                {
                    //否则为圆弧
                    HOperatorSet.TupleInt(((1.0 * hv_Length2) / (hv_Elements - 1)) * hv_i, out hv_j);
                    hv_ArcType = "arc";
                }
                //索引越界，强制赋值为最后一个索引
                if ((int)(new HTuple(hv_j.TupleGreaterEqual(hv_Length2))) != 0)
                {
                    hv_j = hv_Length2 - 1;
                    //continue
                }
                //获取卡尺工具中心
                hv_RowE = hv_RowXLD.TupleSelect(hv_j);
                hv_ColE = hv_ColXLD.TupleSelect(hv_j);

                //超出图像区域，不检测，否则容易报异常
                if ((int)((new HTuple((new HTuple((new HTuple(hv_RowE.TupleGreater(hv_Height - 1))).TupleOr(
                    new HTuple(hv_RowE.TupleLess(0))))).TupleOr(new HTuple(hv_ColE.TupleGreater(
                    hv_Width - 1))))).TupleOr(new HTuple(hv_ColE.TupleLess(0)))) != 0)
                {
                    continue;
                }
                //边缘搜索方向类型：'inner'搜索方向由圆外指向圆心；'outer'搜索方向由圆心指向圆外
                if ((int)(new HTuple(hv_Direct.TupleEqual("inner"))) != 0)
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                    //角度反向
                    hv_ATan = ((new HTuple(180)).TupleRad()) + hv_ATan;
                }
                else
                {
                    //求卡尺工具的边缘搜索方向
                    //求圆心指向边缘的矢量的角度
                    HOperatorSet.TupleAtan2((-hv_RowE) + hv_RowC, hv_ColE - hv_ColumnC, out hv_ATan);
                }


                //产生卡尺xld，并保持到显示对象
                ho_Rectangle1.Dispose();
                HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, hv_RowE, hv_ColE, hv_ATan,
                    hv_DetectHeight / 2, hv_DetectWidth / 2);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle1, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
                //用箭头xld指示边缘搜索方向，并保持到显示对象
                if ((int)(new HTuple(hv_i.TupleEqual(0))) != 0)
                {
                    hv_RowL2 = hv_RowE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_RowL1 = hv_RowE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_ColL2 = hv_ColE + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    hv_ColL1 = hv_ColE - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    ho_Arrow1.Dispose();
                    gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                        5, 5);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }

            }

            ho_Contour.Dispose();
            ho_ContCircle.Dispose();
            ho_Rectangle1.Dispose();
            ho_Arrow1.Dispose();

            return;
        }


        public static void get_rake_region(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
    HTuple hv_DetectHeight, HTuple hv_DetectWidth, EumTestModule eumTestModule = EumTestModule.create, 
                HObject searchROI = null, HTuple hv_Row1 = null, HTuple hv_Row2 = null,
                HTuple hv_Column1 = null, HTuple hv_Column2 = null)
        {
            HTuple hv_Row , hv_Column;
            HTuple _Row1, _Column1, _Row2, _Column2;
            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Rectangle = null;
            HObject ho_Arrow1 = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ResultRow = null;
            HTuple hv_ResultColumn = null, hv_ATan = null, hv_i = null;
            HTuple hv_RowC = new HTuple(), hv_ColC = new HTuple();
            HTuple hv_Distance = new HTuple(), hv_RowL2 = new HTuple();
            HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
            HTuple hv_ColL1 = new HTuple();
            HTuple hv_DetectWidth_COPY_INP_TMP = hv_DetectWidth.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Arrow1);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //初始化边缘坐标数组
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();

            if (eumTestModule == EumTestModule.create)
            {
                if (hv_Row1 == null || hv_Row2 == null || hv_Column1 == null || hv_Column2 == null)
                {
                    ho_Regions = null;
                    return;
                }
                 
                _Row1 = hv_Row1.TupleSelect(0);
                _Row2 = hv_Row2.TupleSelect(0);
                _Column1 = hv_Column1.TupleSelect(0);
                _Column2 = hv_Column2.TupleSelect(0);
            }
            else
            {
                HOperatorSet.GetContourXld(searchROI, out hv_Row, out hv_Column);
                _Row1 = hv_Row.TupleSelect(0);
                _Row2 = hv_Row.TupleSelect(1);
                _Column1 = hv_Column.TupleSelect(0);
                _Column2 = hv_Column.TupleSelect(1);
            }

            //产生直线xld
            ho_RegionLines.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_RegionLines, _Row1.TupleConcat(_Row2),
                _Column1.TupleConcat(_Column2));
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            HOperatorSet.AngleLx(_Row1, _Column1, _Row2, _Column2, out hv_ATan);

            //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
            hv_ATan = hv_ATan + ((new HTuple(90)).TupleRad());

            //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
            HTuple end_val18 = hv_Elements;
            HTuple step_val18 = 1;
            for (hv_i = 1; hv_i.Continue(end_val18, step_val18); hv_i = hv_i.TupleAdd(step_val18))
            {
                //RowC := Row1+(((Row2-Row1)*i)/(Elements+1))
                //ColC := Column1+(Column2-Column1)*i/(Elements+1)
                //if (RowC>Height-1 or RowC<0 or ColC>Width-1 or ColC<0)
                //continue
                //endif
                //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
                if ((int)(new HTuple(hv_Elements.TupleEqual(1))) != 0)
                {
                    hv_RowC = (_Row1 + _Row2) * 0.5;
                    hv_ColC = (_Column1 + _Column2) * 0.5;
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    HOperatorSet.DistancePp(_Row1, _Column1, _Row2, _Column2, out hv_Distance);
                    hv_DetectWidth_COPY_INP_TMP = hv_Distance.Clone();
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                        hv_ATan, hv_DetectHeight / 2, hv_Distance / 2);
                }
                else
                {
                    //如果有多个测量矩形，产生该测量矩形xld
                    hv_RowC = _Row1 + (((_Row2 - _Row1) * (hv_i - 1)) / (hv_Elements - 1));
                    hv_ColC = _Column1 + (((_Column2 - _Column1) * (hv_i - 1)) / (hv_Elements - 1));
                    //判断是否超出图像,超出不检测边缘
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                        new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                        hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                    {
                        continue;
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                        hv_ATan, hv_DetectHeight / 2, hv_DetectWidth_COPY_INP_TMP / 2);
                }

                //把测量矩形xld存储到显示对象
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
                if ((int)(new HTuple(hv_i.TupleEqual(1))) != 0)
                {
                    //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                    hv_RowL2 = hv_RowC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_RowL1 = hv_RowC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                    hv_ColL2 = hv_ColC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    hv_ColL1 = hv_ColC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                    ho_Arrow1.Dispose();
                    gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                        15, 15);
                    //把xld存储到显示对象
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                        ho_Regions.Dispose();
                        ho_Regions = ExpTmpOutVar_0;
                    }
                }

            }

            ho_RegionLines.Dispose();
            ho_Rectangle.Dispose();
            ho_Arrow1.Dispose();

            return;
        }



        //默认为直线创建
        public static OutputLineFit createOrfitLine1(HObject ho_Image, lineOrcirclefitParma linefitParmadata, HTuple hwinandle,
            EumTestModule eumTestModule = EumTestModule.create,HObject searchROI=null)

        {
            HObject ho_Regions = null, ho_Line = null, Contour = null;
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out Contour);
            HTuple hv_Row = null, hv_Column = null;
            HTuple hv_Row1 = null, hv_Column1 = null, hv_Row2 = null;
            HTuple hv_Column2 = null, hv_ResultRow = null, hv_ResultColumn = null;
            HTuple hv_Row11 = null, hv_Column11 = null, hv_Row21 = null;
            HTuple hv_Column21 = null;
            OutputLineFit temdata = new OutputLineFit();

            try
            {
             
                if (eumTestModule == EumTestModule.create)
                {
                    draw_rake(hwinandle, out hv_Row1, out hv_Column1, out hv_Row2, out hv_Column2);
                    Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out Contour, hv_Row1.TupleConcat(hv_Row2),
                          hv_Column1.TupleConcat(hv_Column2));
                    temdata.SearchRegion = Contour;
                   
                }                 
                else
                {
                    HOperatorSet.GetContourXld(searchROI,out hv_Row,out hv_Column);
                    hv_Row1 = hv_Row.TupleSelect(0);
                    hv_Row2 = hv_Row.TupleSelect(1);
                    hv_Column1 = hv_Column.TupleSelect(0);
                    hv_Column2 = hv_Column.TupleSelect(1);
                }
                ho_Regions.Dispose();
                rake(ho_Image, out ho_Regions, linefitParmadata.CaliperNum, linefitParmadata.CaliperHeight,
                    linefitParmadata.CaliperWidth, 1, linefitParmadata.edgeThreshold,
                       Enum.GetName(typeof(lineOrcirclefitTransition), linefitParmadata.edgeTransition),
                         Enum.GetName(typeof(lineOrcirclefitSelect), linefitParmadata.edgeSelect),
                          hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_ResultRow, out hv_ResultColumn);
                if (eumTestModule == EumTestModule.create)//创建模式
                {
                    HObject ho_Region = null;
                    HOperatorSet.GenEmptyObj(out ho_Region);
                    ho_Region.Dispose();
                    get_rake_region(ho_Image, out ho_Region, linefitParmadata.CaliperNum, linefitParmadata.CaliperHeight,
                        linefitParmadata.CaliperWidth, eumTestModule, searchROI, hv_Row1, hv_Row2,
                        hv_Column1, hv_Column2);
                    HOperatorSet.ConcatObj(ho_Regions, ho_Region, out ho_Regions);
                    ho_Region.Dispose();
                }
                temdata.ResultRegion = ho_Regions;

                ho_Line.Dispose();
                pts_to_best_line(out ho_Line, hv_ResultRow, hv_ResultColumn, 2, out hv_Row11,
                    out hv_Column11, out hv_Row21, out hv_Column21);
                temdata.resultobj = ho_Line;
                temdata.hv_ResultRow = hv_ResultRow;
                temdata.hv_ResultColumn = hv_ResultColumn;
                temdata.pointstrucList.Add(new pointstruct(hv_Row11, hv_Column11));
                temdata.pointstrucList.Add(new pointstruct(hv_Row21, hv_Column21));
            }
            catch (Exception er)
            {
                temdata = null;
            }
            return temdata;


        }
        //默认为直线创建
        public static OutputLineFit createOrfitLine2(HObject ho_Image, lineOrcirclefitParma linefitParmadata, HTuple hwinandle,
              EumTestModule eumTestModule = EumTestModule.create, HObject searchROI = null)
        {
            HObject ho_Regions1 = null, ho_Line1 = null, Contour = null;
            HOperatorSet.GenEmptyObj(out ho_Regions1);
            HOperatorSet.GenEmptyObj(out ho_Line1);
            HOperatorSet.GenEmptyObj(out Contour);
            HTuple hv_Row = null, hv_Column = null;
            HTuple hv_Row12 = null, hv_Column12 = null;
            HTuple hv_Row22 = null, hv_Column22 = null, hv_ResultRow1 = null;
            HTuple hv_ResultColumn1 = null, hv_Row13 = null, hv_Column13 = null;
            HTuple hv_Row23 = null, hv_Column23 = null;

            OutputLineFit temdata = new OutputLineFit();

            try
            {
                if (eumTestModule == EumTestModule.create)
                {
                    draw_rake(hwinandle, out hv_Row12, out hv_Column12, out hv_Row22, out hv_Column22);
                    Contour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out Contour, hv_Row12.TupleConcat(hv_Row22),
                          hv_Column12.TupleConcat(hv_Column22));
                    temdata.SearchRegion = Contour;
                }
                else
                {
                    HOperatorSet.GetContourXld(searchROI, out hv_Row, out hv_Column);
                    hv_Row12 = hv_Row.TupleSelect(0);
                    hv_Row22 = hv_Row.TupleSelect(1);
                    hv_Column12 = hv_Column.TupleSelect(0);
                    hv_Column22 = hv_Column.TupleSelect(1);
                }
                      
                ho_Regions1.Dispose();
                rake(ho_Image, out ho_Regions1, linefitParmadata.CaliperNum, linefitParmadata.CaliperHeight,
                    linefitParmadata.CaliperWidth, 1, linefitParmadata.edgeThreshold,
                    Enum.GetName(typeof(lineOrcirclefitTransition), linefitParmadata.edgeTransition),
                        Enum.GetName(typeof(lineOrcirclefitSelect), linefitParmadata.edgeSelect),
                    hv_Row12, hv_Column12, hv_Row22, hv_Column22, out hv_ResultRow1, out hv_ResultColumn1);
                if (eumTestModule == EumTestModule.create)//创建模式
                {
                    HObject ho_Region = null;
                    HOperatorSet.GenEmptyObj(out ho_Region);
                    ho_Region.Dispose();
                    get_rake_region(ho_Image, out ho_Region, linefitParmadata.CaliperNum, linefitParmadata.CaliperHeight,
                        linefitParmadata.CaliperWidth, eumTestModule, searchROI, hv_Row12, hv_Row22,
                        hv_Column12, hv_Column22);
                    HOperatorSet.ConcatObj(ho_Regions1, ho_Region, out ho_Regions1);
                    ho_Region.Dispose();
                }

                temdata.ResultRegion = ho_Regions1;
                ho_Line1.Dispose();
                pts_to_best_line(out ho_Line1, hv_ResultRow1, hv_ResultColumn1, 2, out hv_Row13,
                    out hv_Column13, out hv_Row23, out hv_Column23);

                temdata.resultobj = ho_Line1;
                temdata.hv_ResultRow = hv_ResultRow1;
                temdata.hv_ResultColumn = hv_ResultColumn1;
                temdata.pointstrucList.Add(new pointstruct(hv_Row13, hv_Column13));
                temdata.pointstrucList.Add(new pointstruct(hv_Row23, hv_Column23));
            }
            catch (Exception er)
            {
                temdata=null;
            }
           
            return temdata;

        }
        // Main procedure 
        static public OutputLineInsect IntersectAction(OutputLineFit line1, OutputLineFit line2)
        {
            // Local iconic variables 


            HObject ho_Cross;

            // Local control variables       
            HTuple hv_Row = null;
            HTuple hv_Column = null, hv_IsOverlapping = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Cross);
            OutputLineInsect temdata = new OutputLineInsect();
            try
            {

                HOperatorSet.IntersectionLines(line1.pointstrucList[0].row, line1.pointstrucList[0].column,
                    line1.pointstrucList[1].row, line1.pointstrucList[1].column,
                    line2.pointstrucList[0].row, line2.pointstrucList[0].column,
                    line2.pointstrucList[1].row, line2.pointstrucList[1].column, out hv_Row, out hv_Column,
                    out hv_IsOverlapping);
                temdata.pointstrucList.Add(new pointstruct(hv_Row, hv_Column));
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_Row, hv_Column, 20, 0.785398);
                temdata.resultobj = ho_Cross;

                //disp_message(3600, ((("x:" + hv_Column) + ",") + "y:") + hv_Row, "image", hv_Row - 50,
                //    hv_Column + 50, "cyan", "false");
            }
            catch (HalconException HDevExpDefaultException)
            {


            }
            return temdata;

        }

        //默认为圆创建
        static public bool DrawCirclefitROI(HObject ho_Image, lineOrcirclefitParma circlefitParmadata,
            HTuple hwinandle, ref OutputCircleFit temdata,
              EumTestModule eumTestModule = EumTestModule.create, HObject searchROI = null,
              EumCircleDirection eumCircleDirection = EumCircleDirection.inner)
        {
            // Local iconic variables 
            temdata.pointstrucList.Clear();
            HObject ho_Regions, Contour = null;

            // Local control variables 

            HTuple hv_ROIRows = null, hv_ROICols = null;
            HTuple hv_Direct = null, hv_ResultRow = null, hv_ResultColumn = null;
            HTuple hv_ArcType = null;

            // Initialize local and output iconic variables 

            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out Contour);

            if (eumTestModule == EumTestModule.create)
            {
                draw_spoke(ho_Image, hwinandle, out hv_ROIRows, out hv_ROICols, out hv_Direct);
                if (hv_ROIRows == null || hv_ROIRows.Length < 4)
                    return false;
                Contour.Dispose();              
                HOperatorSet.GenContourPolygonXld(out Contour, hv_ROIRows, hv_ROICols);
                temdata.SearchRegion = Contour;
                temdata.hv_Direct = hv_Direct;
            }
            else
            {
                hv_Direct = Enum.GetName(typeof(EumCircleDirection), eumCircleDirection);
                HOperatorSet.GetContourXld(searchROI, out hv_ROIRows, out hv_ROICols);
                temdata.hv_Direct = hv_Direct;
            }
            ho_Regions.Dispose();
            spoke(ho_Image, out ho_Regions, circlefitParmadata.CaliperNum, circlefitParmadata.CaliperHeight,
                   circlefitParmadata.CaliperWidth, 1, circlefitParmadata.edgeThreshold,
                   Enum.GetName(typeof(lineOrcirclefitTransition), circlefitParmadata.edgeTransition),
                     Enum.GetName(typeof(lineOrcirclefitSelect), circlefitParmadata.edgeSelect),
               hv_ROIRows, hv_ROICols, hv_Direct, out hv_ResultRow, out hv_ResultColumn, out hv_ArcType);

            if (eumTestModule == EumTestModule.create)//创建模式
            {
                HObject ho_Region = null;
                HOperatorSet.GenEmptyObj(out ho_Region);
                ho_Region.Dispose();
                get_spoke_region(ho_Image, out ho_Region, circlefitParmadata.CaliperNum, circlefitParmadata.CaliperHeight,
                    circlefitParmadata.CaliperWidth, hv_Direct, eumTestModule,  searchROI, hv_ROIRows, hv_ROICols
                   );
                HOperatorSet.ConcatObj(ho_Regions, ho_Region, out ho_Regions);
                ho_Region.Dispose();
            }


            temdata.ResultRegion = ho_Regions;
            temdata.hv_ResultRow = hv_ResultRow;
            temdata.hv_ResultColumn = hv_ResultColumn;
            temdata.hv_ArcType = hv_ArcType;
            return true;
        }

       static public void  fitcircle( 
           ref OutputCircleFit temdata)
        {
            // Local iconic variables 
         
            HObject ho_Circle;

            // Local control variables 
    
        
            HTuple hv_RowCenter = null, hv_ColCenter = null;
            HTuple hv_Radius = null, hv_StartPhi = null, hv_EndPhi = null;
            HTuple hv_PointOrder = null, hv_ArcAngle = null;
            // Initialize local and output iconic variables 
            try
            {
             
                HOperatorSet.GenEmptyObj(out ho_Circle);
            
                ho_Circle.Dispose();
                pts_to_best_circle(out ho_Circle, temdata.hv_ResultRow, temdata.hv_ResultColumn,
                    temdata.hv_ArcType,
                    10, out hv_RowCenter, out hv_ColCenter, out hv_Radius, out hv_StartPhi, out hv_EndPhi,
                    out hv_PointOrder, out hv_ArcAngle);
                temdata.resultobj = ho_Circle;
                temdata.radius = hv_Radius.D;
                temdata.pointstrucList.Add(new pointstruct(hv_RowCenter, hv_ColCenter));
              
            }

            catch (Exception er)
            {
                temdata = null;
            }
                
        }
    }

    public struct pointstruct
    {
        public pointstruct(HTuple r, HTuple c)
        {
            row = r;
            column = c;
        }

        public HTuple row;
        public HTuple column;
    }



    public class OutputLineFit
    {
       
        public OutputLineFit()
        {
            pointstrucList = new List<pointstruct>();

        }
        public HTuple hv_ResultRow, hv_ResultColumn;
        public HObject SearchRegion;
        public HObject resultobj;
        public HObject ResultRegion;
        public List<pointstruct> pointstrucList;

    }

    public class OutputLineInsect
    {

        public OutputLineInsect()
        {
            pointstrucList = new List<pointstruct>();

        }

        public HObject resultobj;
     
        public List<pointstruct> pointstrucList;

    }
    public class OutputCircleFit
    {

        public OutputCircleFit()
        {
            pointstrucList = new List<pointstruct>();

        }
        public HTuple hv_ResultRow, hv_ResultColumn, hv_ArcType, hv_Direct;
        public HObject resultobj;
        public HObject SearchRegion;
        public HObject ResultRegion;
        public List<pointstruct> pointstrucList;
        public double radius;
    }


    public enum lineOrcirclefitTransition
    {
        positive,
        negative,
        all
    }
    public enum lineOrcirclefitSelect
    {
        first,
        last,
        max
    }
    /// <summary>
    /// 前处理工具
    /// </summary>
    [Serializable]
    public class PretreatmentTool
    {
        public PretreatmentTool()
        {
            pretreatmentDats = new List<PretreatmentDat>();
        }

        /// <summary>
        /// 是否使用前处理工具
        /// </summary>
        public bool isUsingPretreatment = false;
        /// <summary>
        /// 前处理工具集合
        /// </summary>
        public List<PretreatmentDat> pretreatmentDats = null;
    }

    /// <summary>
    /// 前处理
    /// </summary>
    [Serializable]
    abstract public class PretreatmentDat
    {
        /// <summary>
        /// 工具名称
        /// </summary>
        public string toolName;

    }

    /// <summary>
    ///  轨迹提取参数
    /// </summary>
    [Serializable]
    public class TrajectoryExtractParam
    {
        public TrajectoryExtractParam()
        {
            pointName = "P1";
            pretreatmentTool = new PretreatmentTool();
            HOperatorSet.GenEmptyObj(out inspectRegion);
        }
        ~TrajectoryExtractParam()
        {
            inspectRegion?.Dispose();
        }
        /// <summary>
        /// 检测区域
        /// </summary>
        public HObject inspectRegion = null;
        /// <summary>
        /// 点位名称
        /// </summary>
        public string pointName = "";
        /// <summary>
        /// 前处理工具
        /// </summary>
        public PretreatmentTool pretreatmentTool = null;
        /// <summary>
        /// 圆查找方向
        /// </summary>
        public   HTuple spokeCircleDirection;

        /// <summary>
        /// 采样点数
        /// </summary>
        public int pointNum = 20;
        /// <summary>
        /// 起点设定
        /// </summary>
        public EumStartP startP = EumStartP.左;
        //轨迹提取设定曝光值
        public long expouse = 1000;
        //曲线类型
        public EumTrackType trackType = EumTrackType.AnyCurve;

    }

    public enum EumStartP
    { 
       上,
       下,
       左,
       右
    }

    /// <summary>
    /// 曲线类型枚举
    /// </summary>
    public enum EumTrackType
    {
        [Description("任意")]
        /// <summary>
        /// 任意曲线
        /// </summary>
        AnyCurve,

        [Description("直线")]
        /// <summary>
        /// 直线
        /// </summary>
        Line,

        [Description("圆弧")]
        /// <summary>
        /// 圆弧
        /// </summary>
        Circle
    
    }



    //直线、圆拟合运行参数
    [Serializable]
    public  class lineOrcirclefitParma : TrajectoryExtractParam
    {
        public lineOrcirclefitParma()
        {
            edgeThreshold = 30;
            CaliperNum = 30;
            CaliperWidth = 15;
            CaliperHeight = 300;
            edgeTransition = lineOrcirclefitTransition.all;
            edgeSelect = lineOrcirclefitSelect.max;
            Direction = "";
           // detectROI = new HObject();
        }
        public lineOrcirclefitParma(HTuple _edgeThreshold, HTuple _CaliperNum,
                   HTuple _CaliperWidth, HTuple _CaliperHeight,
                  lineOrcirclefitTransition _edgeTransition, lineOrcirclefitSelect _edgeSelect)
        {
            edgeThreshold = _edgeThreshold;
            CaliperNum = _CaliperNum;
            CaliperWidth = _CaliperWidth;
            CaliperHeight = _CaliperHeight;
            edgeTransition = _edgeTransition;
            edgeSelect = _edgeSelect;
        }
        public HTuple edgeThreshold;
        public HTuple CaliperNum;
        public HTuple CaliperWidth;
        public HTuple CaliperHeight;
        public lineOrcirclefitTransition edgeTransition;
        public lineOrcirclefitSelect edgeSelect;
        public string Direction;

        /// <summary>
        /// 检测区域
        /// </summary>
     //   public HObject detectROI;

        /// <summary>
        ///  参数更新
        /// </summary>
        /// <param name="_edgeThreshold"></param>
        /// <param name="_CaliperNum"></param>
        /// <param name="_CaliperWidth"></param>
        /// <param name="_CaliperHeight"></param>
        /// <param name="_edgeTransition"></param>
        /// <param name="_edgeSelect"></param>
        public void updateParam(HTuple _edgeThreshold, HTuple _CaliperNum,
                   HTuple _CaliperWidth, HTuple _CaliperHeight,
                  lineOrcirclefitTransition _edgeTransition, lineOrcirclefitSelect _edgeSelect)
        {
            edgeThreshold = _edgeThreshold;
            CaliperNum = _CaliperNum;
            CaliperWidth = _CaliperWidth;
            CaliperHeight = _CaliperHeight;
            edgeTransition = _edgeTransition;
            edgeSelect = _edgeSelect;
        }
    }
    [Serializable]
    public class BlobRunParmas
    {
        public BlobRunParmas()
        {
             thresholdDown = 20;
             threasholdUp = 100;
        }
        public HTuple thresholdDown { get; set; }
        public HTuple threasholdUp { get; set; }

    }

    public enum  EumTestModule
    {
        create,   //创建
        fit       //拟合
    }

    public enum EumCircleDirection
    {
        inner,
        outer
    }

}

