//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//
using System;
using HalconDotNet;

namespace FunctionLib.GlueWidth
{
    public partial class GlueWidthMeasure
    {

        public GlueWidthMeasure()
        {
     
        }


        // Procedures 
        // External procedures 
        static private void get_rake2_region(HObject ho_Image, out HObject ho_Regions, HTuple hv_DetectHeight,
            HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Rectangle;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
            HTuple hv_RowC = null, hv_ColC = null, hv_Distance = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);

            //产生直线xld
            ho_RegionLines.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_Row1.TupleConcat(hv_Row2),
                hv_Column1.TupleConcat(hv_Column2));
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            HOperatorSet.AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_ATan);

            //边缘检测方向：直线方向为边缘检测方向
            hv_ATan = hv_ATan + ((new HTuple(0)).TupleRad());

            //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
            hv_RowC = (hv_Row1 + hv_Row2) * 0.5;
            hv_ColC = (hv_Column1 + hv_Column2) * 0.5;
            //判断是否超出图像,超出不检测边缘
            if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
            {
                ho_RegionLines.Dispose();
                ho_Rectangle.Dispose();

                return;
            }
            HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Distance);
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC, hv_ATan,
                hv_Distance / 2, hv_DetectHeight / 2);


            //把测量矩形xld存储到显示对象
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_Regions, ho_Rectangle, out ExpTmpOutVar_0);
                ho_Regions.Dispose();
                ho_Regions = ExpTmpOutVar_0;
            }

            //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
            //RowL2 := RowC+Distance/2*sin(-ATan)
            //RowL1 := RowC-Distance/2*sin(-ATan)
            //ColL2 := ColC+Distance/2*cos(-ATan)
            //ColL1 := ColC-Distance/2*cos(-ATan)
            //gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, DetectHeight/2, DetectHeight/2)
            //把xld存储到显示对象
            //concat_obj (Regions, Arrow1, Regions)

            ho_RegionLines.Dispose();
            ho_Rectangle.Dispose();

            return;
        }

        // Chapter: XLD / Creation
        // Short Description: Creates an arrow shaped XLD contour. 
        static private void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
            HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = null, hv_ZeroLengthIndices = null;
            HTuple hv_DR = null, hv_DC = null, hv_HalfHeadWidth = null;
            HTuple hv_RowP1 = null, hv_ColP1 = null, hv_RowP2 = null;
            HTuple hv_ColP2 = null, hv_Index = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            //This procedure generates arrow shaped XLD contours,
            //pointing from (Row1, Column1) to (Row2, Column2).
            //If starting and end point are identical, a contour consisting
            //of a single point is returned.
            //
            //input parameteres:
            //Row1, Column1: Coordinates of the arrows' starting points
            //Row2, Column2: Coordinates of the arrows' end points
            //HeadLength, HeadWidth: Size of the arrow heads in pixels
            //
            //output parameter:
            //Arrow: The resulting XLD contour
            //
            //The input tuples Row1, Column1, Row2, and Column2 have to be of
            //the same length.
            //HeadLength and HeadWidth either have to be of the same length as
            //Row1, Column1, Row2, and Column2 or have to be a single element.
            //If one of the above restrictions is violated, an error will occur.
            //
            //
            //Init
            ho_Arrow.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            //
            //Calculate the arrow length
            HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
            //
            //Mark arrows with identical start and end point
            //(set Length to -1 to avoid division-by-zero exception)
            hv_ZeroLengthIndices = hv_Length.TupleFind(0);
            if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
            {
                if (hv_Length == null)
                    hv_Length = new HTuple();
                hv_Length[hv_ZeroLengthIndices] = -1;
            }
            //
            //Calculate auxiliary variables.
            hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
            hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
            hv_HalfHeadWidth = hv_HeadWidth / 2.0;
            //
            //Calculate end points of the arrow head.
            hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
            hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
            hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
            hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
            //
            //Finally create output XLD contour for each input point pair
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                {
                    //Create_ single points for arrows with identical start and end point
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(hv_Index),
                        hv_Column1.TupleSelect(hv_Index));
                }
                else
                {
                    //Create arrow contour
                    ho_TempArrow.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                        hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                        hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                        ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                        hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                        hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                    ho_Arrow.Dispose();
                    ho_Arrow = ExpTmpOutVar_0;
                }
            }
            ho_TempArrow.Dispose();

            return;
        }

        // Chapter: Graphics / Text
        // Short Description: This procedure writes a text message. 
        static void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
          HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
            HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
            HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
            HTuple hv_WidthWin = null, hv_HeightWin = null, hv_MaxAscent = null;
            HTuple hv_MaxDescent = null, hv_MaxWidth = null, hv_MaxHeight = null;
            HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
            HTuple hv_FactorColumn = new HTuple(), hv_UseShadow = null;
            HTuple hv_ShadowColor = null, hv_Exception = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
            HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
            HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_CurrentColor = new HTuple();
            HTuple hv_Box_COPY_INP_TMP = hv_Box.Clone();
            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
            HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

            // Initialize local and output iconic variables 
            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Column: The column coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically
            //   for each new textline.
            //Box: If Box[0] is set to 'true', the text is written within an orange box.
            //     If set to' false', no box is displayed.
            //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
            //       the text is written in a box of that color.
            //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
            //       'true' -> display a shadow in a default color
            //       'false' -> display no shadow (same as if no second value is given)
            //       otherwise -> use given string as color string for the shadow color
            //
            //Prepare window
            HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetPart(hv_WindowHandle, out hv_Row1Part, out hv_Column1Part, out hv_Row2Part,
                out hv_Column2Part);
            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_RowWin, out hv_ColumnWin,
                out hv_WidthWin, out hv_HeightWin);
            HOperatorSet.SetPart(hv_WindowHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
            //
            //default settings
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
            {
                hv_Color_COPY_INP_TMP = "";
            }
            //
            hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
            //
            //Estimate extentions of text depending on font size.
            HOperatorSet.GetFontExtents(hv_WindowHandle, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
            {
                hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                hv_C1 = hv_Column_COPY_INP_TMP.Clone();
            }
            else
            {
                //Transform image to window coordinates
                hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
            }
            //
            //Display text box depending on text size
            hv_UseShadow = 1;
            hv_ShadowColor = "gray";
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
            {
                if (hv_Box_COPY_INP_TMP == null)
                    hv_Box_COPY_INP_TMP = new HTuple();
                hv_Box_COPY_INP_TMP[0] = "#fce9d4";
                hv_ShadowColor = "#f28d26";
            }
            if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
                1))) != 0)
            {
                if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
                {
                    //Use default ShadowColor set above
                }
                else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
                    "false"))) != 0)
                {
                    hv_UseShadow = 0;
                }
                else
                {
                    hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
                    //Valid color?
                    try
                    {
                        HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                            1));
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
                        throw new HalconException(hv_Exception);
                    }
                }
            }
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
            {
                //Valid color?
                try
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
                    throw new HalconException(hv_Exception);
                }
                //Calculate box extents
                hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                hv_Width = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                    hv_Width = hv_Width.TupleConcat(hv_W);
                }
                hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    ));
                hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                hv_R2 = hv_R1 + hv_FrameHeight;
                hv_C2 = hv_C1 + hv_FrameWidth;
                //Display rectangles
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                HOperatorSet.SetDraw(hv_WindowHandle, "fill");
                //Set shadow color
                HOperatorSet.SetColor(hv_WindowHandle, hv_ShadowColor);
                if ((int)(hv_UseShadow) != 0)
                {
                    HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1 + 1, hv_C1 + 1, hv_R2 + 1, hv_C2 + 1);
                }
                //Set box color
                HOperatorSet.SetColor(hv_WindowHandle, hv_Box_COPY_INP_TMP.TupleSelect(0));
                HOperatorSet.DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                HOperatorSet.SetDraw(hv_WindowHandle, hv_DrawMode);
            }
            //Write text.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                    )));
                if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                    "auto")))) != 0)
                {
                    HOperatorSet.SetColor(hv_WindowHandle, hv_CurrentColor);
                }
                else
                {
                    HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                }
                hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                HOperatorSet.SetTposition(hv_WindowHandle, hv_Row_COPY_INP_TMP, hv_C1);
                HOperatorSet.WriteString(hv_WindowHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index));
            }
            //Reset changed window settings
            HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                hv_Column2Part);

            return;
        }

        static private void ExtendLine(HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2, HTuple hv_Column2,
            HTuple hv_ExtendLength, out HTuple hv_RowStart, out HTuple hv_ColStart, out HTuple hv_RowEnd,
            out HTuple hv_ColEnd)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Phi = null;
            // Initialize local and output iconic variables 

            //获取该直线的位置信息
            HOperatorSet.AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Phi);
            //line_position (Row1, Column1, Row2, Column2, RowCenter, ColCenter, Length, Phi)
            //********************生成延长线***********************
            //延长线长度（不精确）
            //ExtendLength := 200

            //起点
            hv_RowStart = hv_Row1 - ((((hv_Phi + 1.5707963)).TupleCos()) * hv_ExtendLength);
            hv_ColStart = hv_Column1 - ((((hv_Phi + 1.5707963)).TupleSin()) * hv_ExtendLength);
            //终点
            hv_RowEnd = hv_Row2 - ((((hv_Phi - 1.5707963)).TupleCos()) * hv_ExtendLength);
            hv_ColEnd = hv_Column2 - ((((hv_Phi - 1.5707963)).TupleSin()) * hv_ExtendLength);


            return;
        }

        static private void pts_to_best_line(out HObject ho_Line, HTuple hv_Rows, HTuple hv_Cols,
            HTuple hv_ActiveNum, out HTuple hv_Row1, out HTuple hv_Column1, out HTuple hv_Row2,
            out HTuple hv_Column2)
        {



            // Local iconic variables 

            HObject ho_Contour = null;

            // Local control variables 

            HTuple hv_Length = null, hv_Nr = new HTuple();
            HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_Length1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            //初始化
            hv_Row1 = 0;
            hv_Column1 = 0;
            hv_Row2 = 0;
            hv_Column2 = 0;
            //产生一个空的直线对象，用于保存拟合后的直线
            ho_Line.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Line);
            //计算边缘数量
            HOperatorSet.TupleLength(hv_Cols, out hv_Length);
            //当边缘数量不小于有效点数时进行拟合
            if ((int)((new HTuple(hv_Length.TupleGreaterEqual(hv_ActiveNum))).TupleAnd(new HTuple(hv_ActiveNum.TupleGreater(
                1)))) != 0)
            {
                //halcon的拟合是基于xld的，需要把边缘连接成xld
                ho_Contour.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_Rows, hv_Cols);
                //拟合直线。使用的算法是'tukey'，其他算法请参考fit_line_contour_xld的描述部分。
                HOperatorSet.FitLineContourXld(ho_Contour, "tukey", -1, 0, 5, 2, out hv_Row1,
                    out hv_Column1, out hv_Row2, out hv_Column2, out hv_Nr, out hv_Nc, out hv_Dist);
                //判断拟合结果是否有效：如果拟合成功，数组中元素的数量大于0
                HOperatorSet.TupleLength(hv_Dist, out hv_Length1);
                if ((int)(new HTuple(hv_Length1.TupleLess(1))) != 0)
                {
                    ho_Contour.Dispose();

                    return;
                }
                //根据拟合结果，产生直线xld
                ho_Line.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_Line, hv_Row1.TupleConcat(hv_Row2),
                    hv_Column1.TupleConcat(hv_Column2));
            }

            ho_Contour.Dispose();

            return;
        }

        static void draw_rake(HTuple hv_WindowHandle, out HTuple hv_Row1, out HTuple hv_Column1,
              out HTuple hv_Row2, out HTuple hv_Column2)
        {



            // Local iconic variables 

            HObject ho_Regions;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            if (hv_WindowHandle.D > 100000)
                HOperatorSet.SetFont(hv_WindowHandle, "Courier New-" + "12");
            else
                HOperatorSet.SetFont(hv_WindowHandle, "-Courier New-" + "12" + "-*-*-*-*-1-");
            //提示
            disp_message(hv_WindowHandle, new HTuple("点击鼠标左键画一条直线,点击右键确认"),
                "image", 12, 12, "red", "false");
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //画矢量检测直线
            HOperatorSet.DrawLine(hv_WindowHandle, out hv_Row1, out hv_Column1, out hv_Row2,
                out hv_Column2);
            //产生直线xld
            //gen_contour_polygon_xld (RegionLines, [Row1,Row2], [Column1,Column2])
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            //angle_lx (Row1, Column1, Row2, Column2, ATan)

            //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
            //ATan := ATan+rad(90)

            //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
            //for i := 1 to Elements by 1
            //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
            //if (Elements=1)
            //RowC := (Row1+Row2)*0.5
            //ColC := (Column1+Column2)*0.5
            //distance_pp (Row1, Column1, Row2, Column2, Distance)
            //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, Distance/2)
            //else
            //如果有多个测量矩形，产生该测量矩形xld
            //RowC := Row1+(((Row2-Row1)*(i-1))/(Elements-1))
            //ColC := Column1+(Column2-Column1)*(i-1)/(Elements-1)
            //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, DetectHeight/2, DetectWidth/2)
            //endif
            //把测量矩形xld存储到显示对象
            //concat_obj (Regions, Rectangle, Regions)
            //if (i=1)
            //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
            //RowL2 := RowC+DetectHeight/2*sin(-ATan)
            //RowL1 := RowC-DetectHeight/2*sin(-ATan)
            //ColL2 := ColC+DetectHeight/2*cos(-ATan)
            //ColL1 := ColC-DetectHeight/2*cos(-ATan)
            //gen_arrow_contour_xld (Arrow1, RowL1, ColL1, RowL2, ColL2, 5, 5)
            //把xld存储到显示对象
            //concat_obj (Regions, Arrow1, Regions)
            //endif
            //endfor

            ho_Regions.Dispose();

            return;
        }

        static private void rakePoint(HObject ho_Image, out HObject ho_Regions, HTuple hv_Sigma,
            HTuple hv_Threshold, HTuple hv_Transition, HTuple hv_Select, HTuple hv_row1,
            HTuple hv_col1, HTuple hv_row2, HTuple hv_col2, HTuple hv_DetectHeight, out HTuple hv_ResultRow,
            out HTuple hv_ResultColumn)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Cross = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
            HTuple hv_Distance = null, hv_DetectWidth = null, hv_RowC = null;
            HTuple hv_ColC = null, hv_MsrHandle_Measure = null, hv_RowEdge = null;
            HTuple hv_ColEdge = null, hv_Amplitude = null, hv_tRow = null;
            HTuple hv_tCol = null, hv_t = null, hv_Number = null, hv_j = null;
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //初始化边缘坐标数组
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();
            //产生直线xld
            ho_RegionLines.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_row1.TupleConcat(hv_row2),
                hv_col1.TupleConcat(hv_col2));
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            HOperatorSet.AngleLx(hv_row1, hv_col1, hv_row2, hv_col2, out hv_ATan);

            HOperatorSet.DistancePp(hv_row1, hv_col1, hv_row2, hv_col2, out hv_Distance);
            hv_DetectWidth = hv_Distance.Clone();
            //边缘检测方向平行于于检测直线：直线方向°为边缘检测方向
            hv_ATan = hv_ATan + ((new HTuple(0)).TupleRad());

            ////中心点
            hv_RowC = (hv_row1 + hv_row2) / 2;
            hv_ColC = (hv_col1 + hv_col2) / 2;


            //产生测量对象句柄
            HOperatorSet.GenMeasureRectangle2(hv_RowC, hv_ColC, hv_ATan, hv_DetectWidth / 2,
                hv_DetectHeight / 2, hv_Width, hv_Height, "nearest_neighbor", out hv_MsrHandle_Measure);

            //设置极性
            if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
            {
                hv_Transition_COPY_INP_TMP = "negative";
            }
            else
            {
                if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                {

                    hv_Transition_COPY_INP_TMP = "positive";
                }
                else
                {
                    hv_Transition_COPY_INP_TMP = "all";
                }
            }
            //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
            if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
            {
                hv_Select_COPY_INP_TMP = "first";
            }
            else
            {
                if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                {

                    hv_Select_COPY_INP_TMP = "last";
                }
                else
                {
                    hv_Select_COPY_INP_TMP = "all";
                }
            }
            //检测边缘
            HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                out hv_Amplitude, out hv_Distance);
            //清除测量对象句柄
            HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);

            //临时变量初始化
            //tRow，tCol保存找到指定边缘的坐标
            hv_tRow = 0;
            hv_tCol = 0;
            //t保存边缘的幅度绝对值
            hv_t = 0;
            //找到的边缘必须至少为1个
            HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
            if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
            {
                ho_RegionLines.Dispose();
                ho_Cross.Dispose();

                return;
            }
            //有多个边缘时，选择幅度绝对值最大的边缘
            HTuple end_val66 = hv_Number - 1;
            HTuple step_val66 = 1;
            for (hv_j = 0; hv_j.Continue(end_val66, step_val66); hv_j = hv_j.TupleAdd(step_val66))
            {
                if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                    hv_t))) != 0)
                {

                    hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                    hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                    hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                }
            }
            //把找到的边缘保存在输出数组
            if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
            {
                hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
            }
            ////结果
            if ((int)(new HTuple((new HTuple(hv_ResultRow.TupleLength())).TupleGreater(0))) != 0)
            {
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
                    4, 0.785398);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Cross, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
            }
            ho_RegionLines.Dispose();
            ho_Cross.Dispose();

            return;
        }

        // Local procedures 
        static private void rakeex(HObject ho_Image, out HObject ho_Regions, HTuple hv_Sigma,
           HTuple hv_Threshold, HTuple hv_Transition, HTuple hv_Select, HTuple hv_row1,
            HTuple hv_col1, HTuple hv_row2, HTuple hv_col2, HTuple hv_DetectHeight, out HTuple hv_ResultRow,
            out HTuple hv_ResultColumn)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RegionLines, ho_Rectangle, ho_Contour;
            HObject ho_Contour1, ho_Cross = null;

            // Local control variables 

            HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
            HTuple hv_Distance = null, hv_DetectWidth = null, hv_RowC = null;
            HTuple hv_ColC = null, hv_Row = null, hv_Col = null, hv_DistanceMin = null;
            HTuple hv_DistanceMin1 = null, hv_rc1 = null, hv_cc1 = null;
            HTuple hv_rc2 = null, hv_cc2 = null, hv_Distance1 = null;
            HTuple hv_numP = null, hv_i = null, hv_RC = new HTuple();
            HTuple hv_CC = new HTuple(), hv_MsrHandle_Measure = new HTuple();
            HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
            HTuple hv_Amplitude = new HTuple(), hv_tRow = new HTuple();
            HTuple hv_tCol = new HTuple(), hv_t = new HTuple(), hv_Number = new HTuple();
            HTuple hv_j = new HTuple();
            HTuple hv_Select_COPY_INP_TMP = hv_Select.Clone();
            HTuple hv_Transition_COPY_INP_TMP = hv_Transition.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Contour1);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            //获取图像尺寸
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //产生一个空显示对象，用于显示
            ho_Regions.Dispose();
            HOperatorSet.GenEmptyObj(out ho_Regions);
            //初始化边缘坐标数组
            hv_ResultRow = new HTuple();
            hv_ResultColumn = new HTuple();
            //产生直线xld
            ho_RegionLines.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_row1.TupleConcat(hv_row2),
                hv_col1.TupleConcat(hv_col2));
            //存储到显示对象
            //concat_obj (Regions, RegionLines, Regions)
            //计算直线与x轴的夹角，逆时针方向为正向。
            HOperatorSet.AngleLx(hv_row1, hv_col1, hv_row2, hv_col2, out hv_ATan);

            HOperatorSet.DistancePp(hv_row1, hv_col1, hv_row2, hv_col2, out hv_Distance);
            hv_DetectWidth = hv_Distance.Clone();
            //边缘检测方向平行于于检测直线：直线方向°为边缘检测方向
            hv_ATan = hv_ATan + ((new HTuple(0)).TupleRad());

            ////中心点
            hv_RowC = (hv_row1 + hv_row2) / 2;
            hv_ColC = (hv_col1 + hv_col2) / 2;
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC, hv_ATan,
                hv_DetectWidth / 2, hv_DetectHeight / 2);
            HOperatorSet.GetContourXld(ho_Rectangle, out hv_Row, out hv_Col);
            ////排序
            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Row.TupleSelect(0))).TupleConcat(
                hv_Row.TupleSelect(1)), ((hv_Col.TupleSelect(0))).TupleConcat(hv_Col.TupleSelect(
                1)));
            HOperatorSet.DistanceCcMin(ho_Contour, ho_RegionLines, "point_to_segment", out hv_DistanceMin);
            ho_Contour1.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour1, ((hv_Row.TupleSelect(1))).TupleConcat(
                hv_Row.TupleSelect(2)), ((hv_Col.TupleSelect(1))).TupleConcat(hv_Col.TupleSelect(
                2)));
            HOperatorSet.DistanceCcMin(ho_Contour1, ho_RegionLines, "point_to_segment", out hv_DistanceMin1);
            hv_rc1 = 0;
            hv_cc1 = 0;
            hv_rc2 = 0;
            hv_cc2 = 0;
            if ((int)(new HTuple(hv_DistanceMin.TupleGreater(hv_DistanceMin1))) != 0)
            {
                hv_rc1 = ((hv_Row.TupleSelect(0)) + (hv_Row.TupleSelect(1))) / 2.0;
                hv_cc1 = ((hv_Col.TupleSelect(0)) + (hv_Col.TupleSelect(1))) / 2.0;
                hv_rc2 = ((hv_Row.TupleSelect(2)) + (hv_Row.TupleSelect(3))) / 2.0;
                hv_cc2 = ((hv_Col.TupleSelect(2)) + (hv_Col.TupleSelect(3))) / 2.0;
            }
            else
            {
                hv_rc1 = ((hv_Row.TupleSelect(1)) + (hv_Row.TupleSelect(2))) / 2.0;
                hv_cc1 = ((hv_Col.TupleSelect(1)) + (hv_Col.TupleSelect(2))) / 2.0;
                hv_rc2 = ((hv_Row.TupleSelect(3)) + (hv_Row.TupleSelect(4))) / 2.0;
                hv_cc2 = ((hv_Col.TupleSelect(3)) + (hv_Col.TupleSelect(4))) / 2.0;
            }

            HOperatorSet.DistancePp(hv_rc1, hv_cc1, hv_rc2, hv_cc2, out hv_Distance1);


            //根据检测直线按顺序产生测量区域矩形，并存储到显示对象

            hv_numP = hv_DetectHeight / 10;
            if ((int)(new HTuple(hv_numP.TupleLess(2))) != 0)
            {
                hv_numP = 2;
            }


            HTuple end_val56 = hv_numP;
            HTuple step_val56 = 1;
            for (hv_i = 1; hv_i.Continue(end_val56, step_val56); hv_i = hv_i.TupleAdd(step_val56))
            {

                //如果有多个测量矩形，产生该测量矩形xld
                hv_RC = hv_rc1 + (((hv_rc2 - hv_rc1) * (hv_i - 1)) / (hv_numP - 1));
                hv_CC = hv_cc1 + (((hv_cc2 - hv_cc1) * (hv_i - 1)) / (hv_numP - 1));
                //判断是否超出图像,超出不检测边缘
                if ((int)((new HTuple((new HTuple((new HTuple(hv_RC.TupleGreater(hv_Height - 1))).TupleOr(
                    new HTuple(hv_RC.TupleLess(0))))).TupleOr(new HTuple(hv_CC.TupleGreater(
                    hv_Width - 1))))).TupleOr(new HTuple(hv_CC.TupleLess(0)))) != 0)
                {
                    continue;
                }
                //gen_rectangle2 (Rectangle1, RC, CC, ATan, DetectWidth/2, 5)
                //产生测量对象句柄
                HOperatorSet.GenMeasureRectangle2(hv_RC, hv_CC, hv_ATan, hv_DetectWidth / 2,
                    5, hv_Width, hv_Height, "nearest_neighbor", out hv_MsrHandle_Measure);

                //设置极性
                if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("negative"))) != 0)
                {
                    hv_Transition_COPY_INP_TMP = "negative";
                }
                else
                {
                    if ((int)(new HTuple(hv_Transition_COPY_INP_TMP.TupleEqual("positive"))) != 0)
                    {

                        hv_Transition_COPY_INP_TMP = "positive";
                    }
                    else
                    {
                        hv_Transition_COPY_INP_TMP = "all";
                    }
                }
                //设置边缘位置。最强点是从所有边缘中选择幅度绝对值最大点，需要设置为'all'
                if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("first"))) != 0)
                {
                    hv_Select_COPY_INP_TMP = "first";
                }
                else
                {
                    if ((int)(new HTuple(hv_Select_COPY_INP_TMP.TupleEqual("last"))) != 0)
                    {

                        hv_Select_COPY_INP_TMP = "last";
                    }
                    else
                    {
                        hv_Select_COPY_INP_TMP = "all";
                    }
                }
                //检测边缘
                HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                    hv_Transition_COPY_INP_TMP, hv_Select_COPY_INP_TMP, out hv_RowEdge, out hv_ColEdge,
                    out hv_Amplitude, out hv_Distance);
                //清除测量对象句柄
                HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);

                //临时变量初始化
                //tRow，tCol保存找到指定边缘的坐标
                hv_tRow = 0;
                hv_tCol = 0;
                //t保存边缘的幅度绝对值
                hv_t = 0;
                //找到的边缘必须至少为1个
                HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
                if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
                {
                    continue;
                }
                //有多个边缘时，选择幅度绝对值最大的边缘
                HTuple end_val108 = hv_Number - 1;
                HTuple step_val108 = 1;
                for (hv_j = 0; hv_j.Continue(end_val108, step_val108); hv_j = hv_j.TupleAdd(step_val108))
                {
                    if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                        hv_t))) != 0)
                    {

                        hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                        hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                        hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                    }
                }
                //把找到的边缘保存在输出数组
                if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
                {
                    hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                    hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
                }
            }
            if ((int)(new HTuple((new HTuple(hv_ResultRow.TupleLength())).TupleGreater(0))) != 0)
            {
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
                    4, 0.785398);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Cross, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
            }
            ho_RegionLines.Dispose();
            ho_Rectangle.Dispose();
            ho_Contour.Dispose();
            ho_Contour1.Dispose();
            ho_Cross.Dispose();

            return;
        }



        /// <summary>
        /// 工具测量
        /// </summary>
        /// <param name="ho_Image"></param>
        /// <param name="winHandle"></param>
        /// <param name="data"></param>
        /// <param name="setting"></param>
        /// <param name="searchROI"></param>
        /// <returns></returns>
        static public StuGlueWidthResult Run(HObject ho_Image, GlueWidthParam data,
            EumSetting setting, HObject searchROI = null, HTuple winHandle = null)
        {
            StuGlueWidthResult result = new StuGlueWidthResult(0);

            try
            {
                if (setting == EumSetting.create)//创建
                {
                    //绘制区域
                    draw_rake(winHandle, out HTuple hv_Row12, out HTuple hv_Column12,
                                            out HTuple hv_Row22, out HTuple hv_Column22);

                    HOperatorSet.GenContourPolygonXld(out HObject Contour, hv_Row12.TupleConcat(hv_Row22),
                        hv_Column12.TupleConcat(hv_Column22));
                    result.drawPoints.Dispose();
                    HOperatorSet.CopyObj(Contour, out result.drawPoints, 1, -1);

                    //搜索区域
                    get_rake2_region(ho_Image, out HObject ho_Regions11, data.hv_DetectHeight, hv_Row12, hv_Column12, hv_Row22,
                        hv_Column22);
                    result.searchRegion.Dispose();
                    HOperatorSet.CopyObj(ho_Regions11, out result.searchRegion, 1, -1);
                 
                    result.runFlag = true;//运行状态
                }
                else//测试
                {
                    HOperatorSet.GetContourXld(searchROI, out HTuple hv_Row, out HTuple hv_Column);
                    HTuple hv_Row1 = hv_Row.TupleSelect(0);
                    HTuple hv_Row2 = hv_Row.TupleSelect(1);
                    HTuple hv_Column1 = hv_Column.TupleSelect(0);
                    HTuple hv_Column2 = hv_Column.TupleSelect(1);

                    //搜索区域
                    get_rake2_region(ho_Image, out HObject ho_Regions11, data.hv_DetectHeight, hv_Row1, hv_Column1, hv_Row2,
                        hv_Column2);
                    result.searchRegion.Dispose();
                    HOperatorSet.CopyObj(ho_Regions11, out result.searchRegion, 1, -1);
                    //结果区域
                  
                    rakeex(ho_Image, out HObject ho_Regions, data.hv_Sigma, data.hv_Threshold, 
                        Enum.GetName(typeof(EumTransition), data.hv_Transition),
                      Enum.GetName(typeof(EumSelect), data.hv_Select),
                       hv_Row1, hv_Column1,
                        hv_Row2, hv_Column2, data.hv_DetectHeight, out HTuple hv_ResultRow, out HTuple hv_ResultColumn);
                    if (hv_ResultRow == null || hv_ResultRow.TupleLength() <= 0)
                    {
                        result.errInfo = "边缘1识别失败";//运行状态
                        result.runFlag = false;//错误信息
                        return result;
                    }

                    pts_to_best_line(out HObject ho_Line, hv_ResultRow, hv_ResultColumn, 2, out HTuple Row1,
                        out HTuple Column1, out HTuple Row2, out HTuple Column2);

                    ExtendLine(Row1, Column1, Row2, Column2, 100, out HTuple hv_RowStart, out HTuple hv_ColStart,
                        out HTuple hv_RowEnd, out HTuple hv_ColEnd);

                  
                    HOperatorSet.GenContourPolygonXld(out HObject ho_Contour, hv_RowStart.TupleConcat(hv_RowEnd),
                        hv_ColStart.TupleConcat(hv_ColEnd));

                    string Transition = "negative";
                    if (Enum.GetName(typeof(EumTransition), data.hv_Transition) == "positive")
                        Transition = "negative";
                    else
                        Transition = "positive";

                    rakeex(ho_Image, out HObject ho_Regions1, data.hv_Sigma, data.hv_Threshold,
                     Transition,
                    Enum.GetName(typeof(EumSelect), data.hv_Select),
                     hv_Row1, hv_Column1,
                      hv_Row2, hv_Column2, data.hv_DetectHeight, out HTuple hv_ResultRow1, out HTuple hv_ResultColumn1);

                    if(hv_ResultRow1==null|| hv_ResultRow1.TupleLength()<=0)
                    {
                        result.errInfo = "边缘2识别失败";//运行状态
                        result.runFlag = false;//错误信息
                        return result;
                    }

                    pts_to_best_line(out HObject ho_Line2, hv_ResultRow1, hv_ResultColumn1, 2, out HTuple Row21,
                     out HTuple Column21, out HTuple Row22, out HTuple Column22);

                    ExtendLine(Row21, Column21, Row22, Column22, 100, out HTuple hv_RowStart2, out HTuple hv_ColStart2,
                     out HTuple hv_RowEnd2, out HTuple hv_ColEnd2);

                    HOperatorSet.GenContourPolygonXld(out HObject ho_Contour2, hv_RowStart2.TupleConcat(hv_RowEnd2),
                     hv_ColStart2.TupleConcat(hv_ColEnd2));

                    //rakePoint(ho_Image, out HObject ho_Regions1, data.hv_Sigma, data.hv_Threshold,
                    //  Transition,
                    //  Enum.GetName(typeof(EumSelect), data.hv_Select),
                    //  hv_Row1, hv_Column1,
                    //    hv_Row2, hv_Column2, data.hv_DetectHeight, out HTuple hv_ResultRow1, out HTuple hv_ResultColumn1);
                    HTuple rc = (hv_RowStart2 + hv_RowEnd2) / 2.0;
                    HTuple cc = (hv_ColStart2 + hv_ColEnd2) / 2.0;

                    HOperatorSet.GenCrossContourXld(out HObject ho_Cross, rc, cc,
                        6, 0.785398);

                    HOperatorSet.ProjectionPl(rc, cc, hv_RowStart, hv_ColStart, hv_RowEnd, hv_ColEnd,
                        out HTuple hv_RowProj, out HTuple hv_ColProj);

                    HOperatorSet.DistancePl(rc, cc, hv_RowStart, hv_ColStart, hv_RowEnd, hv_ColEnd,out HTuple hv_Distance);

                    HOperatorSet.GenContourPolygonXld(out HObject ho_Contour1, rc.TupleConcat(hv_RowProj),
                        cc.TupleConcat(hv_ColProj));


                    HOperatorSet.ConcatObj(ho_Contour, ho_Contour2, out HObject objectsConcat);
                    HOperatorSet.ConcatObj(objectsConcat, ho_Contour1, out HObject objectsConcat2);
                    HOperatorSet.ConcatObj(objectsConcat2, ho_Cross, out HObject objectsConcat3);

                    //rake2(ho_Image, out HObject ho_Regions,
                    //    data.hv_DetectHeight, data.hv_Sigma, data.hv_Threshold,
                    //Enum.GetName(typeof(EumTransition), data.hv_Transition),
                    //  Enum.GetName(typeof(EumSelect), data.hv_Select),
                    //    hv_Row1, hv_Column1,
                    //    hv_Row2, hv_Column2, out HTuple hv_ResultRow1, out HTuple hv_ResultColumn1, out HTuple hv_Distance);
                    result.ho_Regions.Dispose();
                    HOperatorSet.CopyObj(objectsConcat3, out result.ho_Regions, 1, -1);
                    result.hv_ResultRows = rc.TupleConcat(hv_RowProj);//点位
                    result.hv_ResultColumns = cc.TupleConcat(hv_ColProj);//点位
                    result.hv_Distance = hv_Distance;//距离
                    result.runFlag = true;//运行状态
                }
            }
            catch (Exception er)
            {
                result.errInfo = er.Message;//运行状态
                result.runFlag = false;//错误信息
            }
            return result;
        }

        // Main procedure 
        private void action()
        {


            // Local iconic variables 

            HObject ho_Image, ho_Regions11, ho_Regions;
            HObject ho_Line, ho_Contour, ho_Regions1, ho_Cross, ho_Contour1;

            // Local control variables 

            HTuple hv_Row12 = null, hv_Column12 = null;
            HTuple hv_Row22 = null, hv_Column22 = null, hv_ResultRow = null;
            HTuple hv_ResultColumn = null, hv_Row1 = null, hv_Column1 = null;
            HTuple hv_Row2 = null, hv_Column2 = null, hv_RowStart = null;
            HTuple hv_ColStart = null, hv_RowEnd = null, hv_ColEnd = null;
            HTuple hv_ResultRow1 = null, hv_ResultColumn1 = null, hv_RowProj = null;
            HTuple hv_ColProj = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Regions11);
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_Line);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Regions1);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Contour1);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetColored(HDevWindowStack.GetActive(), 12);
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
            }

            ho_Image.Dispose();
            HOperatorSet.ReadImage(out ho_Image, "E:/images/P1.jpg");


            /////间距测量

            /////卡尺2

            draw_rake(200000, out hv_Row12, out hv_Column12, out hv_Row22, out hv_Column22);

            ho_Regions11.Dispose();
            get_rake2_region(ho_Image, out ho_Regions11, 50, hv_Row12, hv_Column12, hv_Row22,
                hv_Column22);

            ho_Regions.Dispose();
            rakeex(ho_Image, out ho_Regions, 1, 20, "positive", "all", hv_Row12, hv_Column12,
                hv_Row22, hv_Column22, 50, out hv_ResultRow, out hv_ResultColumn);

            ho_Line.Dispose();
            pts_to_best_line(out ho_Line, hv_ResultRow, hv_ResultColumn, 2, out hv_Row1,
                out hv_Column1, out hv_Row2, out hv_Column2);

            ExtendLine(hv_Row1, hv_Column1, hv_Row2, hv_Column2, 100, out hv_RowStart, out hv_ColStart,
                out hv_RowEnd, out hv_ColEnd);

            ho_Contour.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour, hv_RowStart.TupleConcat(hv_RowEnd),
                hv_ColStart.TupleConcat(hv_ColEnd));

            ho_Regions1.Dispose();
            rakePoint(ho_Image, out ho_Regions1, 1, 20, "negative", "all", hv_Row12, hv_Column12,
                hv_Row22, hv_Column22, 50, out hv_ResultRow1, out hv_ResultColumn1);

            ho_Cross.Dispose();
            HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow1, hv_ResultColumn1,
                6, 0.785398);

            HOperatorSet.ProjectionPl(hv_ResultRow1.TupleSelect(0), hv_ResultColumn1.TupleSelect(
                0), hv_RowStart, hv_ColStart, hv_RowEnd, hv_ColEnd, out hv_RowProj, out hv_ColProj);

            ho_Contour1.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Contour1, ((hv_ResultRow1.TupleSelect(
                0))).TupleConcat(hv_RowProj), ((hv_ResultColumn1.TupleSelect(0))).TupleConcat(
                hv_ColProj));


            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Contour1, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
            }

            ho_Image.Dispose();
            ho_Regions11.Dispose();
            ho_Regions.Dispose();
            ho_Line.Dispose();
            ho_Contour.Dispose();
            ho_Regions1.Dispose();
            ho_Cross.Dispose();
            ho_Contour1.Dispose();

        }


    }
}


